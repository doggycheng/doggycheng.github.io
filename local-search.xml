<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2. 两数相加</title>
    <link href="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p></blockquote><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这里以 <code>22 + 79</code> 为例，我们看一下大致的流程</p><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-00.svg" alt></p><blockquote><p><code>22+79=101</code>，我们的链表逆序存储，返回的结果应为 <code>1 → 0 → 1</code></p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-01.svg" alt></p><blockquote><p>我们初始化一个链表，用来存放求和结果，这里设置了两个指针 <code>dummy</code> 和 <code>head</code>，其中 <code>head</code> 跟随着计算结果不断指向链表尾部，<code>dummy</code> 一直指向初始化链表的头部，最后返回 <code>dummy.next</code> 就可以得到所求的链表</p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-02.svg" alt></p><blockquote><p>首先是个位相加，得到结果 11，所以个位求和后，进位为1，本位也为 1，因此 <code>head</code> 的下一个结点存放本位的结果 1。</p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-03.svg" alt></p><blockquote><p>上一步个位求和结果有进位 1，因此这里要求和的是 <code>1+2+7=10</code>，即进位为1，本位为 0。 <code>head</code> 的下一个结点存放本位的结果 0</p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-04.svg" alt></p><blockquote><p>上一步进行十位求和的结果中有一个进位 1，所以我们还需要继续计算下去，但是一开始求和的是两位数 22 和 79，存放这两个数值的链表取到百位的时候是 <code>None</code>，<code>None</code> 是没有属性 <code>val</code>，因此计算时要把 <code>val</code> 赋为 0。最后计算得到 <code>1</code>，本位为 1，进位为 0。</p><p><code>head</code> 的下一个结点存放本位的结果 1，这时候 <code>dummy</code> 指向的是初始化的头结点，返回 <code>dummy.next</code> 才是所求的链表</p></blockquote><p>图中的流程大致可以用文字描述为：</p><ul><li>初始化一个存放结果的链表 <code>head</code>，初始化进位 <code>c</code> 为0；</li><li>如果 <code>l1</code> 或 <code>l2</code> 非空或者 <code>c</code> 非 0<ul><li>进行求和；如果 <code>l1</code> 非空，则取出 <code>l1</code> 中存放的值 <code>v_1</code>，若 <code>l1</code> 为空则设 <code>v_1</code> 为 0，<code>l2</code> 同理；</li><li>求和，<code>sum = c + v_1 + v_2</code>，计算进位 <code>c = sum //10</code>，链表下一个结点存放的值为本位 <code>head.next = ListNode(sum % 10)</code>；</li><li><code>head</code> 移动后链表尾部，<code>l1</code> 移动到下一个结点，如果 <code>l1</code> 为空则继续为设空，<code>l2</code> 同理。</li></ul></li><li>流程结束，返回 <code>dummy.next</code> 得到结果。</li></ul><p>根据上述流程，实现的 python 代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br>        dummy = head = ListNode()<br>        c = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> c:<br>            v_1 = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            v_2 = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-built_in">sum</span> = c + v_1 + v_2<br>            c = <span class="hljs-built_in">sum</span> // <span class="hljs-number">10</span><br>            head.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-built_in">sum</span> % <span class="hljs-number">10</span>)<br>            head = head.<span class="hljs-built_in">next</span><br>            l1 = l1.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>            l2 = l2.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 两数之和</title>
    <link href="/2021/05/22/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/05/22/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a></p></blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 103</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>利用两个 <code>for</code> 循环，找到求和等于 <code>target</code> 的数字下标即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,n):<br>                <span class="hljs-keyword">if</span> nums[i]+nums[j]==target:<br>                    <span class="hljs-keyword">return</span> [i,j]<br></code></pre></td></tr></table></figure><h2 id="利用字典"><a href="#利用字典" class="headerlink" title="利用字典"></a>利用字典</h2><p>两个 <code>for</code> 循环的时间复杂度为 $O(N^2)$，如果我们用字典记录之前看过的数字和对应的索引，遍历其他数字时，先计算该数字和 <code>target</code> 的差值 <code>diff=target-num</code>，如果 <code>diff</code> 在字典中，我们就能直接返回结果，而字典的查找时间复杂度为 <code>O(1)</code>，整个算法的时间复杂度降到 $O(N)$。流程如下：</p><ul><li>初始化一个字典；</li><li>开始遍历 <code>nums</code> 中的数字 <code>num</code>，计算 <code>diff=target-num</code> ，如果 <code>diff</code> 在字典中，结束流程，返回数字下标；如果 <code>diff</code> 不在字典中，我们在字典中添加一个元素，键为 <code>num</code>，值为 <code>num</code> 的下标；</li><li>不断重复此过程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        lookup = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            diff = target - num<br>            <span class="hljs-keyword">if</span> diff <span class="hljs-keyword">in</span> lookup:<br>                <span class="hljs-keyword">return</span> [lookup[diff],i]<br>            <span class="hljs-keyword">else</span>:<br>                lookup[num] = i<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>算法简介</strong></p><p>二分查找是在<strong>有序数组</strong>中寻找某一元素的查找算法，它的主要思想就是将搜索空间缩小为原来的一半。尽管二分查找的思想非常简单，但是很多人也容易出错，主要问题出现在代码对边界值的处理、比较符号带不带等号这些细节上。</p><p><strong>算法流程</strong></p><ul><li>设数组 <code>arr = [0, 1, …, N]</code>，初始化左边界 <code>left=0</code>，右边界 <code>right=len(arr)-1</code>，<code>mid</code> 为左右指针的中点；</li><li>取出 <code>mid</code> 指向的元素，如果此元素为查找的元素，结束查找过程，并返回结果；</li><li>如果 <code>mid</code> 指向的元素大于查找目标，因为数组有序，因此接下来查找 <code>arr[left, mid-1]</code>；如果此元素小于查找目标，那么接下来查找 <code>arr[mid+1, right]</code>；</li><li>更新 <code>left</code>、<code>right</code> 和 <code>mid</code>，不断重复此过程，如果搜索空间为空，说明数组 <code>arr</code> 中不存在所要寻找的值。</li></ul><p><strong>复杂度分析</strong></p><ul><li>平均时间复杂度 $O(\log N)$</li><li>最坏时间复杂度 $O(\log N)$</li><li>空间复杂度<ul><li>迭代实现： $O(1)$</li><li>递归实现： $O(\log N)$</li></ul></li></ul><h1 id="基本的二分查找"><a href="#基本的二分查找" class="headerlink" title="基本的二分查找"></a>基本的二分查找</h1><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210428231629222.svg" alt></p><blockquote><p>一开始 7 小于 11，下一步需要缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215308600.svg" alt></p><blockquote><p>14 大于 11，在上一步的基础上，缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215338299.svg" alt></p><blockquote><p>找到 11 所在的索引，返回索引值 3</p></blockquote><p>如上图所示，给定数组 <code>arr=[2,4,7,11,14,27]</code> 和 <code>target=11</code> 的查找流程，可用文字描述为：</p><ul><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>进入二分查找的循环体中，结束循环的条件为 <code>left&lt;=right</code>；</p><ul><li>计算 mid，<code>mid=left+(right-left)//2</code>，可以看做向下取整，这里没使用 <code>(left+right)//2</code> ，因为 left 和 right 直接相加时可能会出现溢出的情况；</li><li>判断 <code>arr[mid]</code> 和目标值的大小关系，如果相等，则结束查找流程，返回 target 的索引，即 mid；</li><li>如果 <code>arr[mid]</code> 大于目标值，可以缩小搜索空间为 <code>[left, mid-1]</code> ，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 小于目标值，可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果满足循环的条件，则不断重复此过程。</li></ul></li><li>结束循环，如果没有找到目标值，返回 -1。</li></ul><blockquote><p>结束循环的条件是 <code>left&lt;=right</code>，即我们的搜索空间为 <code>[left, right]</code>，这是一个闭区间。当 <code>left=right</code> 时，搜索空间不为空，仍然需要继续搜索，比如数组 <code>arr=[66]</code> 和 <code>target=66</code>，此时有 <code>left=right=0</code>，搜索空间为闭区间 <code>[0, 0]</code> ，即搜索的数组下标只有 0；如果用了 <code>left&lt;right</code>，就成了半开半闭区间 <code>[0, 0)</code> ，此时是一个空集合，程序不能正确返回结果。</p></blockquote><p>根据上面的描述内容，采用迭代的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">arr, target</span>):</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = left + (right-left)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> arr[mid] == target:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">elif</span> arr[mid]&gt;target:<br>            right = mid-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left = mid+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>采用递归的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">arr, target, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>    left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> left<br>    right = <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> right<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">or</span> left&gt;right:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    mid = left + (right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> arr[mid]==target:<br>        <span class="hljs-keyword">return</span> mid<br>    <span class="hljs-keyword">elif</span> arr[mid]&gt;target:<br>        right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search(arr, target, left, right)<br>    <span class="hljs-keyword">else</span>:<br>        left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search(arr, target, left, right)<br></code></pre></td></tr></table></figure><h1 id="寻找最左边界"><a href="#寻找最左边界" class="headerlink" title="寻找最左边界"></a>寻找最左边界</h1><p><strong>我们先来看看所查找的元素在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215558742.svg" alt></p><blockquote><p>mid 指向的元素刚好是 target，我们要找最左边界，那么需要查看 mid 左边是否还有 4 这个元素，缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215608740.svg" alt></p><blockquote><p>mid 指向的元素2 小于 4，需要缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215621806.svg" alt></p><blockquote><p> 此时 mid 指向的元素刚好为 4，这是跟第一步一样，左边可能还存在元素 4，我们缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429220621111.svg" alt></p><blockquote><p>此时 right &lt; left，跳出循环体，left 指向的即为所查找目标的最左边界</p></blockquote><p><strong>我们再看看查找的目标值不在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221502600.svg" alt></p><blockquote><p>左右两边，目标值均大于 4，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221537732.svg" alt></p><blockquote><p>左边 14 大于目标值 6，缩小搜索空间为左半部分；右边 14 小于目标值 30，继续缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221606076.svg" alt></p><blockquote><p>左右两边均小于目标值，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221625527.svg" alt></p><blockquote><p>缩小搜索空间后，左右两边 right&lt;left ，结束循环。此时左边的 left 指向的元素不为 6，而右边的 left 超出数组边界</p></blockquote><p>二分查找的一个应用是寻找满足条件的最左边界，如果不存在则返回-1，上图的查找流程，可用文字描述为：</p><ul><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>进入二分查找的循环体中，结束循环的条件为 <code>left&lt;=right</code>；</p><ul><li>计算 mid，<code>mid=left+(right-left)//2</code>；</li><li>判断 <code>arr[mid]</code> 和目标值的大小关系，因为我们要找的是最左边界，如果相等，mid 的左边可能依然存在我们的目标值，我们可以缩小搜索空间为 <code>[left, mid-1]</code>，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 大于目标值，可以缩小搜索空间为 <code>[left, mid-1]</code> ，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 小于目标值，可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果满足循环的条件，则不断重复此过程。</li></ul></li><li>结束循环，如果没有找到目标值，返回 -1；</li><li>如果找到目标值，返回 left 即为最左边界。</li></ul><p>根据上面的描述内容，采用迭代的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_left</span>(<span class="hljs-params">arr, target</span>):</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = left + (right - left)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> arr[mid] &gt;= target:<br>            right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;<span class="hljs-built_in">len</span>(arr) <span class="hljs-keyword">or</span> arr[left]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure><p>采用递归的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_left</span>(<span class="hljs-params">arr, target, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>    left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> left<br>    right = <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> right<br>    mid = left + (right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">or</span> left&gt;<span class="hljs-built_in">len</span>(arr):<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[left]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[left]==target:<br>        <span class="hljs-keyword">return</span> left<br>    <span class="hljs-keyword">if</span> arr[mid] &gt;= target:<br>        right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_left(arr, target, left, right)<br>    <span class="hljs-keyword">else</span>:<br>        left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_left(arr, target, left, right)<br></code></pre></td></tr></table></figure><h1 id="寻找最右边界"><a href="#寻找最右边界" class="headerlink" title="寻找最右边界"></a>寻找最右边界</h1><p><strong>我们先来看看所查找的元素在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429223719914.svg" alt></p><blockquote><p>mid 指向的目标值刚好为 4，我们要找的是最右边界，因此需要寻找 mid 右边是否还有 4，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429223732516.svg" alt></p><blockquote><p>mid 指向的元素是 14，大于查找目标4，因此缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429223735600.svg" alt></p><blockquote><p>此时 mid 指向的元素刚好是 4，跟第一步一样，我们要查找 mid 右边是否还有元素 4，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224032037.svg" alt></p><blockquote><p>此时 right&lt;left，循环结束，right 指向的是查找目标的最右边界</p></blockquote><p><strong>我们再看看查找目标不在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224231519.svg" alt></p><blockquote><p>左边目标值 6 大于 4，缩小搜索空间为右半部分；右边目标值 1 小于 4，缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224623562.svg" alt></p><blockquote><p>左边目标值 6 小于 14，缩小搜索空间为左半部分；右边目标值 1 小于2，缩小搜索空间为左边部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224627809.svg" alt></p><blockquote><p>左边目标值 6 大于 14，搜小搜索空间为右半部分；右边 right &lt; 0 &lt; left，循环结束</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224840436.svg" alt></p><blockquote><p>左边 right&lt;left，循环结束，且 right 指向的元素不是目标值</p></blockquote><p>二分查找的另一个应用是寻找满足条件的最右边界，如果不存在则返回-1，上图的查找流程，可用文字描述为：</p><ul><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>进入二分查找的循环体中，结束循环的条件为 <code>left&lt;=right</code>；</p><ul><li>计算 mid，<code>mid=left+(right-left)//2</code>；</li><li>判断 <code>arr[mid]</code> 和目标值的大小关系，因为我们要找的是最左边界，如果相等，mid 的右边可能依然存在我们的目标值，我们可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果 <code>arr[mid]</code> 大于目标值，可以缩小搜索空间为 <code>[left, mid-1]</code> ，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 小于目标值，可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果满足循环的条件，则不断重复此过程。</li></ul></li><li>结束循环，如果没有找到目标值，返回 -1；</li><li>如果找到目标值，返回 right 即为最右边界。</li></ul><p>根据上面的描述内容，采用迭代的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_right</span>(<span class="hljs-params">arr, target</span>):</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = left + (right-left)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> arr[mid]&lt;=target:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> right&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> arr[right]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> right<br></code></pre></td></tr></table></figure><p>采用递归的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_right</span>(<span class="hljs-params">arr, target, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>    left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> left<br>    right = <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> right<br>    mid = left + (right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">or</span> right&lt;<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[right]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[right]==target:<br>        <span class="hljs-keyword">return</span> right<br>    <span class="hljs-keyword">if</span> arr[mid]&lt;=target:<br>        left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_right(arr, target, left, right)<br>    <span class="hljs-keyword">else</span>:<br>        right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_right(arr, target, left, right)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>查找</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>welcome</title>
    <link href="/2021/03/27/welcome/"/>
    <url>/2021/03/27/welcome/</url>
    
    <content type="html"><![CDATA[<p>兴趣使然的博客</p><p><img src="/2021/03/27/welcome/1.jpg" alt></p><script type="math/tex; mode=display">1.01^365=37.7834</script>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
