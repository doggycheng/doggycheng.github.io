<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Base64编码和隐写</title>
    <link href="/2022/02/26/MISC/Base64%E7%BC%96%E7%A0%81%E5%92%8C%E9%9A%90%E5%86%99/"/>
    <url>/2022/02/26/MISC/Base64%E7%BC%96%E7%A0%81%E5%92%8C%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Base64-基本介绍"><a href="#Base64-基本介绍" class="headerlink" title="Base64 基本介绍"></a>Base64 基本介绍</h1><p>Base64 （基底64）这个术语源自 MIME 的 Content-Transfer-Encoding<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://en.wikipedia.org/wiki/Base64">[1]</span></a></sup>，它是一种基于 64 个可打印字符来表示二进制数据的方法。</p><p>因为 $\log_2{64}=6$，所以 Base64 编码每 6 个比特位为 1 个单元，换句话说，Base64 编码将每 3 字节（24 位）转换为 4 个 6 位的字符。</p><blockquote><p>Base64 只是进行了编码，方便数据的传输，并不是加密。</p></blockquote><p>Base64 可打印字符包括大写字母 <code>A-Z</code>、小写字母 <code>a-z</code>、数字 <code>0-9</code>，这样就有 62 个字符了，另外两个字符可能略有不同，通常采用 MIME 中的方式，也就是选择斜杆 <code>/</code> 和加号 <code>+</code> ，这样共 64 个字符，并将等号 <code>=</code> 作为后缀填充。</p><blockquote><p>在 URL 中使用标准 Base64 编码时<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://en.wikipedia.org/wiki/Base64">[1]</span></a></sup>会将 <code>+</code>、<code>/</code> 和 <code>=</code> 字符进行 URL 编码，导致 <code>+</code> 变为 <code>%2B</code>、<code>/</code> 变为 <code>%2F</code> 和 <code>=</code> 变为 <code>%3D</code>，使得字符串变得冗长。为此，有专门针对 URL 的 Base64编码，它将标准 Base64 编码的 <code>+</code> 和 <code>/</code> 字符分别替换为 <code>-</code> 和 <code>_</code>，从而避免对一些特殊字符进行 URL 编码/解码。 </p></blockquote><p>下表为标准 Base64 编码的字符集</p><div class="table-container"><table><thead><tr><th>Index</th><th>Binary</th><th>Char</th><th></th><th>Index</th><th>Binary</th><th>Char</th><th></th><th>Index</th><th>Binary</th><th>Char</th><th></th><th>Index</th><th>Binary</th><th>Char</th></tr></thead><tbody><tr><td>0</td><td>000000</td><td><code>A</code></td><td></td><td>16</td><td>010000</td><td><code>Q</code></td><td></td><td>32</td><td>100000</td><td><code>g</code></td><td></td><td>48</td><td>110000</td><td><code>w</code></td></tr><tr><td>1</td><td>000001</td><td><code>B</code></td><td></td><td>17</td><td>010001</td><td><code>R</code></td><td></td><td>33</td><td>100001</td><td><code>h</code></td><td></td><td>49</td><td>110001</td><td><code>x</code></td></tr><tr><td>2</td><td>000010</td><td><code>C</code></td><td></td><td>18</td><td>010010</td><td><code>S</code></td><td></td><td>34</td><td>100010</td><td><code>i</code></td><td></td><td>50</td><td>110010</td><td><code>y</code></td></tr><tr><td>3</td><td>000011</td><td><code>D</code></td><td></td><td>19</td><td>010011</td><td><code>T</code></td><td></td><td>35</td><td>100011</td><td><code>j</code></td><td></td><td>51</td><td>110011</td><td><code>z</code></td></tr><tr><td>4</td><td>000100</td><td><code>E</code></td><td></td><td>20</td><td>010100</td><td><code>U</code></td><td></td><td>36</td><td>100100</td><td><code>k</code></td><td></td><td>52</td><td>110100</td><td><code>0</code></td></tr><tr><td>5</td><td>000101</td><td><code>F</code></td><td></td><td>21</td><td>010101</td><td><code>V</code></td><td></td><td>37</td><td>100101</td><td><code>l</code></td><td></td><td>53</td><td>110101</td><td><code>1</code></td></tr><tr><td>6</td><td>000110</td><td><code>G</code></td><td></td><td>22</td><td>010110</td><td><code>W</code></td><td></td><td>38</td><td>100110</td><td><code>m</code></td><td></td><td>54</td><td>110110</td><td><code>2</code></td></tr><tr><td>7</td><td>000111</td><td><code>H</code></td><td></td><td>23</td><td>010111</td><td><code>X</code></td><td></td><td>39</td><td>100111</td><td><code>n</code></td><td></td><td>55</td><td>110111</td><td><code>3</code></td></tr><tr><td>8</td><td>001000</td><td><code>I</code></td><td></td><td>24</td><td>011000</td><td><code>Y</code></td><td></td><td>40</td><td>101000</td><td><code>o</code></td><td></td><td>56</td><td>111000</td><td><code>4</code></td></tr><tr><td>9</td><td>001001</td><td><code>J</code></td><td></td><td>25</td><td>011001</td><td><code>Z</code></td><td></td><td>41</td><td>101001</td><td><code>p</code></td><td></td><td>57</td><td>111001</td><td><code>5</code></td></tr><tr><td>10</td><td>001010</td><td><code>K</code></td><td></td><td>26</td><td>011010</td><td><code>a</code></td><td></td><td>42</td><td>101010</td><td><code>q</code></td><td></td><td>58</td><td>111010</td><td><code>6</code></td></tr><tr><td>11</td><td>001011</td><td><code>L</code></td><td></td><td>27</td><td>011011</td><td><code>b</code></td><td></td><td>43</td><td>101011</td><td><code>r</code></td><td></td><td>59</td><td>111011</td><td><code>7</code></td></tr><tr><td>12</td><td>001100</td><td><code>M</code></td><td></td><td>28</td><td>011100</td><td><code>c</code></td><td></td><td>44</td><td>101100</td><td><code>s</code></td><td></td><td>60</td><td>111100</td><td><code>8</code></td></tr><tr><td>13</td><td>001101</td><td><code>N</code></td><td></td><td>29</td><td>011101</td><td><code>d</code></td><td></td><td>45</td><td>101101</td><td><code>t</code></td><td></td><td>61</td><td>111101</td><td><code>9</code></td></tr><tr><td>14</td><td>001110</td><td><code>O</code></td><td></td><td>30</td><td>011110</td><td><code>e</code></td><td></td><td>46</td><td>101110</td><td><code>u</code></td><td></td><td>62</td><td>111110</td><td><code>+</code></td></tr><tr><td>15</td><td>001111</td><td><code>P</code></td><td></td><td>31</td><td>011111</td><td><code>f</code></td><td></td><td>47</td><td>101111</td><td><code>v</code></td><td></td><td>63</td><td>111111</td><td><code>/</code></td></tr><tr><td>Padding</td><td>=</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h1 id="Base64-编码过程"><a href="#Base64-编码过程" class="headerlink" title="Base64 编码过程"></a>Base64 编码过程</h1><p>Base64 编码的步骤大致如下：</p><p>（1）将每个字符转换成二进制，合并得到一个二进制串，如果长度不能被 6 整除，需要进行填充；</p><p>（2）将二进制串按 6 位一组划分，根据 Base64 字符集进行编码；</p><p>（3）Base64 编码后的字符长度不是 4 的倍数时，用一个或两个 <code>=</code> 进行填充。</p><p>以 <code>Man</code> 的 Base64 编码结果 <code>TWFu</code> 为例，其转换过程如下所示</p><p><img src="/2022/02/26/MISC/Base64%E7%BC%96%E7%A0%81%E5%92%8C%E9%9A%90%E5%86%99/base64_1.svg" alt></p><p>在将每 3 个字节转换为 4 个 Base64 字符时，如果要转换的字节数不能被 3 整除，最后会多出 1 个或 2 个字节，这时需要用 0 在末尾补足，使二进制串的长度能够被 6 整除，编码后字符长度不是 4 的倍数的，需要在 Base64 编码后的需要加上一个或两个 <code>=</code> 号，使编码后的长度能被 4 整除。</p><blockquote><p>换句话说，一个 <code>=</code> 表示最后 4 个 Base64 字符（包括 <code>=</code> 在内）解码后可以得到 2 个 8 位的字符，两个 <code>=</code> 表示最后 4 个 Base64 字符（包括 <code>=</code> 在内）解码后可以得到 1 个 8 位的字符。</p><p>不存在 3个 <code>=</code> 的情况，因为这种情况下 4 个 Base64 字符中只有 1 个非填充字符，有效位仅有 6 位，不可能由 8 位字符编码而成。</p></blockquote><p>比如下面的例子，二进制串长度为 16，补上 2 位后的长度才能被 6 整除：</p><p><img src="/2022/02/26/MISC/Base64%E7%BC%96%E7%A0%81%E5%92%8C%E9%9A%90%E5%86%99/base64_2.svg" alt></p><p>再比如下面的例子，二进制串长度为 8，需要补上 4 位后长度才能被 6 整除：</p><p><img src="/2022/02/26/MISC/Base64%E7%BC%96%E7%A0%81%E5%92%8C%E9%9A%90%E5%86%99/base64_3.svg" alt></p><blockquote><p>填充不是必须的，因为无需填充也可以通过编码后的内容计算出缺失的字节。所以在一些实现中填充是必须的，有些却不是。一种必须使用填充的场合是当需要将多个 Base64 编码文件合并为一个文件的时候<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/antineutrino/p/3756106.html">[2]</span></a></sup>。</p></blockquote><h1 id="Base64-解码过程"><a href="#Base64-解码过程" class="headerlink" title="Base64 解码过程"></a>Base64 解码过程</h1><p>解码过程如下：</p><p>（1）根据 Base64 字符集转变成相应的二进制串，如果存在填充字符 <code>=</code> 需要先去掉；</p><p>（2）将二进制串按 8 位一组划分，剩余长度如果不足 8 位，则直接去除；</p><p>（3）将每 8 位二进制串转换为相应的 ASCII 字符。</p><blockquote><p>注：标准 ASCII 码使用 7 位二进制数组合来表示 128 个字符。现在许多基于 x86 的系统都支持使用扩展 ASCII。扩展 ASCII 码使用 8 位二进制数表示  256 个字符。</p></blockquote><p>有无填充字符 <code>=</code> 其实都可以进行 Base64 解压。当只有一个填充字符 <code>=</code> 时，下图分别展示了有无填充字符的解码过程：</p><p><img src="/2022/02/26/MISC/Base64%E7%BC%96%E7%A0%81%E5%92%8C%E9%9A%90%E5%86%99/base64_4.svg" alt></p><p>当只有两个填充字符 <code>=</code> 时，下图分别展示了有无填充字符的解码过程：</p><p><img src="/2022/02/26/MISC/Base64%E7%BC%96%E7%A0%81%E5%92%8C%E9%9A%90%E5%86%99/base64_5.svg" alt></p><h1 id="Base64-隐写"><a href="#Base64-隐写" class="headerlink" title="Base64 隐写"></a>Base64 隐写</h1><p>我们已经知道补 Base64 编码过程中可能存在补 0 的操作，那么补的必须是 0 吗，换成1可不可以？当然可以<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://zhuanlan.zhihu.com/p/349481870">[3]</span></a></sup>。</p><p>因为解码时无论最后补的数是 0 还是 1，都会被删去，修改这些位不会影响解码结果，这便是Base64隐写的原理。</p><blockquote><p>从上文知道，Base64 解压时 8 位一组，不足 8 位的直接去除，所以补的位不影响结果。</p></blockquote><p>我们可以通过修改补 0 位的数据来写入我们想隐写的内容，只不过写入的数据越长，需要的 Base64 编码文本条数就越多。</p><p>一个 <code>=</code> 符号代表着我们可以写入 2 位二进制数据，两个 <code>=</code> 可以写入 4 位二进制数据。</p><blockquote><p>在本文 <code>Base64 编码过程</code>、<code>Base64 解码过程</code> 这两部分可以体现，编码过程中分别补上了 2 个 0 和 4 个 0，解码时中都去掉了。</p></blockquote><p>正常情况下，将 Base64 字符串解码后得到的文本再次进行 Base64 编码，得到的结果应该是和原 Base64 编码一样的，如果不一样说明证明这段 Base64 编码文本有隐写的内容。</p><ul><li>Base64 隐写加密脚本如下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> string<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base64stego_encrypt</span>(<span class="hljs-params">line_list, secret</span>):</span><br>    <span class="hljs-comment"># MIMIE Base64字符集，注意按规范排列，即A-Za-z0-9+/</span><br>    b64charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + <span class="hljs-string">&quot;+&quot;</span> + <span class="hljs-string">&quot;/&quot;</span>  <br>    binary_str = <span class="hljs-string">&quot;&quot;</span><br>    stego_list = []<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> secret:<br>        temp = <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">ord</span>(c))[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)  <span class="hljs-comment"># [2:]用于去掉0b，左侧补零使每个字符用8个比特位编码</span><br>        binary_str += temp<br>    offset = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> line_list:<br>        <span class="hljs-keyword">if</span> offset&gt;=<span class="hljs-built_in">len</span>(binary_str):<br>            <span class="hljs-keyword">break</span><br>        line = line.strip()          <span class="hljs-comment"># 去换行符</span><br>        b64str = base64.b64encode(line.encode(<span class="hljs-string">&quot;ASCII&quot;</span>)).decode(<span class="hljs-string">&quot;ASCII&quot;</span>)<br>        pad_nums = b64str.count(<span class="hljs-string">&quot;=&quot;</span>) <span class="hljs-comment"># 记录填充字符个数</span><br>        <span class="hljs-keyword">if</span> pad_nums!=<span class="hljs-number">0</span>:<br>            c = b64str[-<span class="hljs-number">1</span>-pad_nums]  <span class="hljs-comment"># 去掉“=”后取最后一个字符</span><br>            <span class="hljs-comment"># 一个=可以隐写2位</span><br>            bins = binary_str[offset: offset+(pad_nums*<span class="hljs-number">2</span>)]<br>            offset += pad_nums*<span class="hljs-number">2</span><br>            <span class="hljs-comment"># 隐写数据，注意用MIMIE Base64字符集顺序</span><br>            c_index = b64charset.index(c)<br>            new_c_index = <span class="hljs-built_in">int</span>( <span class="hljs-built_in">bin</span>(c_index)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)[:-(pad_nums*<span class="hljs-number">2</span>)]+bins, <span class="hljs-number">2</span>)<br>            new_c = b64charset[ new_c_index ]<br>            <span class="hljs-comment"># 替换 Base64 字符串</span><br>            b64str = b64str[:-<span class="hljs-number">1</span>-pad_nums] + new_c + <span class="hljs-string">&quot;=&quot;</span> * pad_nums<br>        stego_list.append(b64str)<br>    <span class="hljs-keyword">return</span> stego_list<br><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;plain.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-string">&quot;&quot;&quot;plain.txt</span><br><span class="hljs-string">    this is line 1.</span><br><span class="hljs-string">    tthis is line 2.</span><br><span class="hljs-string">    tthhis is line 3.</span><br><span class="hljs-string">    tthhiis is line 1.</span><br><span class="hljs-string">    tthhiiss is line 2.</span><br><span class="hljs-string">    tthhiiss iis line 3.</span><br><span class="hljs-string">    tthhiiss iiss line 1.</span><br><span class="hljs-string">    tthhiiss iiss lline 2.</span><br><span class="hljs-string">    tthhiiss iiss lliine 3.</span><br><span class="hljs-string">    tthhiiss iiss lliinne 1.</span><br><span class="hljs-string">    tthhiiss iiss lliinnee 2.</span><br><span class="hljs-string">    tthhiiss iiss lliinnee 33.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    plain_lines = f.readlines()<br><br>secret = <span class="hljs-string">&quot;abc&quot;</span><br>stego_list = base64stego_encrypt(plain_lines, secret)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;stego.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> stego_list:<br>        f.write(line + <span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>隐写的信息越长，用来隐写的文本文件也就要越长，上面的代码展示了隐写字符串 <code>abc</code> 的例子。</p><p>经 Base64 隐写后，最终输出的 <code>stego.txt</code> 的内容如下所示</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">dGhpcyBpcyBsaW5lIDEu<br><span class="hljs-attribute">dHRoaXMgaXMgbGluZSAyLm</span>==<br><span class="hljs-attribute">dHRoaGlzIGlzIGxpbmUgMy4</span>=<br>dHRoaGlpcyBpcyBsaW5lIDEu<br><span class="hljs-attribute">dHRoaGlpc3MgaXMgbGluZSAyLl</span>==<br><span class="hljs-attribute">dHRoaGlpc3MgaWlzIGxpbmUgMy6</span>=<br>dHRoaGlpc3MgaWlzcyBsaW5lIDEu<br><span class="hljs-attribute">dHRoaGlpc3MgaWlzcyBsbGluZSAyLi</span>==<br><span class="hljs-attribute">dHRoaGlpc3MgaWlzcyBsbGlpbmUgMy5</span>=<br>dHRoaGlpc3MgaWlzcyBsbGlpbm5lIDEu<br><span class="hljs-attribute">dHRoaGlpc3MgaWlzcyBsbGlpbm5lZSAyLo</span>==<br><span class="hljs-attribute">dHRoaGlpc3MgaWlzcyBsbGlpbm5lZSAzMy7</span>=<br></code></pre></td></tr></table></figure><ul><li>Base64 隐写解密脚本如下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> string<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base64stego_decrypt</span>(<span class="hljs-params">line_list</span>):</span><br>    <span class="hljs-comment"># MIMIE Base64字符集，注意按规范排列，即A-Za-z0-9+/</span><br>    b64charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + <span class="hljs-string">&quot;+&quot;</span> + <span class="hljs-string">&quot;/&quot;</span>  <br>    binary_str = <span class="hljs-string">&quot;&quot;</span><br>    plain_str = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> line_list:<br>        line = line.strip()         <span class="hljs-comment"># 去换行符</span><br>        pad_nums = line.count(<span class="hljs-string">&quot;=&quot;</span>)  <span class="hljs-comment"># 记录填充字符个数</span><br>        check = base64.b64encode(base64.b64decode(line)).decode(<span class="hljs-string">&quot;ASCII&quot;</span>)  <span class="hljs-comment"># base64解码再编码</span><br>        <span class="hljs-keyword">if</span> line!=check:<br>            <span class="hljs-comment"># 去掉=后取最后一个字符</span><br>            c1, c2 = line[-<span class="hljs-number">1</span>-pad_nums], check[-<span class="hljs-number">1</span>-pad_nums]<br>            <span class="hljs-comment"># 计算十进制差值，也就是隐写的数据，注意要用MIMIE Base64字符集顺序</span><br>            diff = <span class="hljs-built_in">abs</span>(b64charset.index(c1)-b64charset.index(c2))<br>            <span class="hljs-comment"># 0bxxxx的字符串，[2:]用于去掉0b</span><br>            <span class="hljs-comment"># 一个“=”隐写2位数据，两个隐写4位，位数不足时左侧补零</span><br>            temp = <span class="hljs-built_in">bin</span>(diff)[<span class="hljs-number">2</span>:].zfill(pad_nums * <span class="hljs-number">2</span>)<br>            binary_str += temp<br>        <span class="hljs-keyword">else</span>:<br>            temp = <span class="hljs-string">&quot;0&quot;</span> * pad_nums * <span class="hljs-number">2</span>  <span class="hljs-comment"># pad_nums为0的话temp为&quot;&quot;</span><br>            binary_str += temp<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(binary_str), <span class="hljs-number">8</span>):<br>        plain_str += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(binary_str[i:i+<span class="hljs-number">8</span>], <span class="hljs-number">2</span>))<br>        <span class="hljs-built_in">print</span>(plain_str)<br>    <span class="hljs-keyword">return</span> plain_str<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;stego.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    file_lines = f.readlines()<br>    base64stego_decrypt(file_lines)<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cnblogs.com/antineutrino/p/3756106.html">https://www.cnblogs.com/antineutrino/p/3756106.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/349481870">https://zhuanlan.zhihu.com/p/349481870</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>MISC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>隐写</tag>
      
      <tag>MISC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 最长回文子串</title>
    <link href="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p></blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;a&quot;</span><br>输出：<span class="hljs-comment">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ac&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>如果字符串 <code>s</code> 是回文串，并且长度大于等于 3，那么字符串 <code>s</code> 去除首尾两个字符的子串也是回文串</p><blockquote><p>长度为 1 的字符串一定是回文串</p></blockquote><p>以 <code>&quot;ababa&quot;</code> 为例<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">[1]</span></a></sup>，如果已知 <code>&quot;bab&quot;</code> 是字符串是回文串，因为 <code>&quot;ababa&quot;</code> 首尾是相同字符 <code>&quot;a&quot;</code>，那么 <code>&quot;ababa&quot;</code> 也是回文串。</p><p>设 $P(i, j)$ 表示 <code>s</code> 的子串 <code>s[i, j]</code> 是否为回文串，即</p><script type="math/tex; mode=display">\begin{equation}  P(i,j) =    \begin{cases}    True  , & \text{如果} s[i, j] 是回文串; \\    False , & \text{其他情况}.  \end{cases}\end{equation}</script><blockquote><p><code>s[i, j]</code> 表示 <code>s</code> 的第 <code>i</code> 到第 <code>j</code> 个字符组成的字符串，可取到右边界</p></blockquote><p>其他情况包括以下两种可能性：</p><ol><li><code>s[i, j]</code> 不是回文串；</li><li><code>i&gt;j</code> 。</li></ol><p>根据上述的公式，可得动态规划的状态转移方程：</p><script type="math/tex; mode=display">P(i,j) = P(i+1,j-1) ∧ (s[i]==s[j])</script><blockquote><p>即：子串为回文串 <strong>且</strong> 当前字符串的首尾字符相同</p></blockquote><p>初始状态：</p><ol><li>字符串长度为 1，一定是回文串，即 $P(i,i)=True$；</li><li>字符串长度为 2，如果字符相同则为回文串，即 $P(i,i+1)=(s[i]==s[j])$ 。</li></ol><p>我们用图片来展示动态规划的流程：</p><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-01.svg" alt="图1 字符串s和动态规划矩阵dp"></p><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-02.svg" alt="图2 初始化dp"></p><blockquote><p>初始化 dp，首先 <code>dp[i][i]=True</code>，表示字符串长度为 1 的一定是回文子串，如果 <code>s[i]==s[i+1]</code>，则 <code>dp[i][i+1]=True</code>，否则 <code>dp[i][i+1]=False</code>。在初始化的过程中，记录最长回文子串的起始位置和对应的长度。</p></blockquote><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-03.svg" alt="图3 遍历长度为3的子串"></p><blockquote><p>初始化时把长度为 1 和长度为 2 的子串遍历完了，下面直接从长度为 3 的子串开始遍历。</p><p>首先是 <code>s[0, 2]</code>，因为 <code>s[1, 1]^(s[i]==s[j]) = True</code>，此时更新最长回文子串的起始位置为 0，长度为 3。</p></blockquote><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-04.svg" alt="图4 继续遍历长度为3的子串"></p><blockquote><p>遍历下一个长度为 3 的子串中，此时的子串为 <code>s[1, 3]</code>，有 <code>s[2, 2]^(s[1]==s[3]) = True</code>，这个回文子串没有大于 3，可以不用更新最长回文子串。</p></blockquote><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-05.svg" alt="图5 全部子串遍历完成"></p><blockquote><p>全部子串（包括长度大于3的子串）遍历完成后得到的上图结果，返回最长回文子串即可。</p></blockquote><p>根据上述过程，实现的 python 代码如下</p><ul><li>时间复杂度：$O(N^2)$</li><li>空间复杂度：$O(N^2)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">1</span>:                  <span class="hljs-comment"># 长度为1，一定是回文串</span><br>            <span class="hljs-keyword">return</span> s<br>        dp = [ [<span class="hljs-literal">False</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        max_len = <span class="hljs-number">1</span>               <span class="hljs-comment"># 最长回文子串长度</span><br>        start = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 最长回文子串长度起始位置</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):        <span class="hljs-comment"># 初始化</span><br>            dp[i][i] = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> i&lt;n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (s[i]==s[i+<span class="hljs-number">1</span>]):<br>                dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-literal">True</span><br>                max_len = <span class="hljs-number">2</span><br>                start = i<br>        <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n+<span class="hljs-number">1</span>):   <span class="hljs-comment"># 子串长度</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):    <span class="hljs-comment"># 起始位置</span><br>                j = L + i - <span class="hljs-number">1</span>     <span class="hljs-comment"># 终止位置，取决于子串长度和起始位置</span><br>                <span class="hljs-keyword">if</span> j&gt;=n:          <span class="hljs-comment"># 终止位置索引越界</span><br>                    <span class="hljs-keyword">break</span><br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> (s[i]==s[j])<br>                <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">and</span> (j-i+<span class="hljs-number">1</span>)&gt;max_len:<br>                    max_len = j - i + <span class="hljs-number">1</span><br>                    start = i<br>        <span class="hljs-keyword">return</span> s[start: start+max_len]<br></code></pre></td></tr></table></figure><h2 id="中心扩展"><a href="#中心扩展" class="headerlink" title="中心扩展"></a>中心扩展</h2><p>观察状态转移方程</p><script type="math/tex; mode=display">\begin{equation}   \begin{cases}    P(i,i)   &= true                          \\    P(i,i+1) &= (S_{i}==S_{i+1})              \\    P(i,j)   &= P(i+1,j-1) ∧ (S_{i}==S_{i+1})  \end{cases}\end{equation}</script><p>找出其中的状态转移链</p><script type="math/tex; mode=display">P(i,j) ← P(i+1,j-1) ← P(i+2,j-2) ← \cdots ← 某一边界情况</script><p>可以发现，所有状态在转移的时候可能性都是唯一的<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">[1]</span></a></sup>，如果我们从每一种边界情况开始扩展，就可以得到所有状态对应的答案。</p><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-06.svg" alt="图6 边界子串长度为1"></p><blockquote><p>边界子串长度为 1 的情况</p></blockquote><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-07.svg" alt="图7 边界子串长度为2"></p><blockquote><p>子串长度为 2 的边界情况</p></blockquote><p>边界即子串长度为 1 或 2，如果两边的字母相同，我们就可以继续扩展，从 $P(i+1,j-1)$ 扩展到 $P(i,j)$，如果两边的字母不同，说明这之后的子串都不是回文串，停止扩展。实现的 python 代码如下</p><ul><li>时间复杂度：$O(N^2)$</li><li>空间复杂度：$O(1)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            left1, right1 = self.expand_around_center(s, i, i)   <span class="hljs-comment"># 从1个字符开始扩展</span><br>            left2, right2 = self.expand_around_center(s, i, i+<span class="hljs-number">1</span>) <span class="hljs-comment"># 从2个字符开始扩展</span><br>            <span class="hljs-keyword">if</span> right1-left1 &gt; end-start:<br>                start, end = left1, right1<br>            <span class="hljs-keyword">if</span> right2-left2 &gt; end-start:<br>                start, end = left2, right2<br>        <span class="hljs-keyword">return</span> s[start: end+<span class="hljs-number">1</span>]<br>            <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expand_around_center</span>(<span class="hljs-params">self, s, i, j</span>):</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">while</span> i&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j&lt;n <span class="hljs-keyword">and</span> s[i]==s[j]:<br>            i -= <span class="hljs-number">1</span><br>            j += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 结束循环时，有 i&lt;0且j&gt;n，或者 s[i]!=s[j]</span><br>        <span class="hljs-comment"># 所以我们 i+1，j-1，回退到最后一个符合条件的位置</span><br>        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>, j-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>Manacher 算法（马拉车算法）本质上还是用中心扩展的思想<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cxyxiaowu.com/2665.html">[2]</span></a></sup>，回文串可分为奇数回文串和偶数回文串，它们的区别是：奇数回文串关于它的“中点”满足“中心对称”，偶数回文串关于它“中间的两个点”满足“中心对称”。</p><p>为了消除字符串长度是奇数和偶数带来的差异，首先需要对字符串进行<strong>预处理</strong>，也就是<strong>添加分隔符</strong>：在字符串的首尾、相邻的字符中插入分隔符，例如 <code>&quot;baba&quot;</code> 添加分隔符 <code>#</code> 以后得到 <code>&quot;#b#a#b#a#&quot;</code> 。</p><blockquote><p>插入分隔符后，不管原字符串长度是奇数还是偶数，最后得到的都是奇数长度的字符串。</p></blockquote><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-08.svg" alt="图8 原字符串插入分隔符"></p><p>我们计算每个位置 <code>i</code> 开始向外扩展的最大回文子串长度，在此过程中记录最大的回文子串长度即可。在计算以 <code>i+1</code> 为中心的回文子串长度时，我们可以利用位置 <code>i</code> 上的信息。分 2 种情况讨论：</p><blockquote><p><code>r</code> 表示当前位置 <code>i</code> 向外扩展的最大右边界，数组 <code>P</code> 来记录每个位置向右扩展的最大长度。</p><p><code>c</code> 表示目前找到的最长回文子串的中心位置，并用 <code>max_len</code> 记录最大回文子串长度。</p></blockquote><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-09.svg" alt="图9 从位置i开始向外对扩展"></p><p>假设我们目前找到的最长子串中心位置为 <code>c=6</code> ，该位置的最大扩展右边界为 <code>r=10</code>，对于以 <code>c</code> 为中心的任何一个回文字符串来说，<code>r</code> 关于 <code>c</code> 的镜像的索引是 <code>l = 2*c - r</code> 。Manacher 的核心就是借助 <code>c</code>、<code>r</code>、<code>l</code> 提供的信息，在求 <code>P[i]</code> 的时候，不用暴力地向两侧扩展，易知以位置 <code>i</code> 为中心的回文字符串的长度为 <code>2*P[i]+1</code>。</p><p><strong>（一）第一种情况，镜像索引向左扩展的步长没有超过已知最大回文子串的左边界，那么 <code>i</code> 处至少可以向外扩展 <code>P[i&#39;]</code> 步</strong></p><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-10.svg" alt="图10 第一种情况"></p><p>如图所示，<strong>此时 <code>i &lt; r</code></strong>，我们不用直接从 <code>i=7</code> 处向外扩展，可以先计算以 <code>i=7</code> 为中心的<strong>最短回文串长度</strong>，在此基础上得到 <code>P[i]</code>。</p><p>先计算 <code>i</code> 的关于 <code>c</code> 的镜像索引 <code>i&#39; = 2*c -i</code>，如果 <code>i&#39; - P[i&#39;]</code> 没有小于 <code>l</code> ，即从位置 <code>i&#39;</code> 向外扩展 <code>p[i&#39;]</code> 步后，没有超出<strong>已知最大回文子串</strong>的左边界，那么位置 <code>i</code> 至少可以向外扩展 <code>P[i&#39;]</code> 步。</p><blockquote><p>这里利用的是以 <code>c</code> 为中心的回文字符串的对称性，只要没有超过这个回文字符串的边界，从 <code>i</code> 往右、左走多少步，和从 <code>i&#39;</code> 往左、右走多少步所看到的字符时一样的，所以在此条件下 <code>i&#39;</code> 能往左走多少步，<code>i</code> 就能往右走多少步。</p></blockquote><p>位置 <code>i</code> 实际可以向外扩展的长度可能会更大，所以还需要在此基础上继续扩展。</p><p><strong>（二）第二种情况，即 <code>i&#39; - P[i&#39;]</code> 小于 <code>l</code>，那么 <code>i</code> 处至少可以向外扩展 <code>r-i</code> 步</strong></p><p><img src="/2022/02/25/LeetCode/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/05-11.svg" alt="图11 第二种情况"></p><p>如图所示，此时 <code>i&#39;-P[i&#39;]=0</code> ，而 <code>l=2</code> ，即从位置 <code>i&#39;</code> 向外扩展 <code>P[i&#39;]</code> 步后，超出<strong>已知最大回文子串</strong>的左边界，所以 <code>P[9]</code>  至少为 <code>r - i = 3</code> 。</p><blockquote><p>即以 <code>i</code> 为中心的最小回文字符串，向右扩展的长度不超过已知最大回文子串的右边界 <code>r</code>，图中例子 <code>r</code> 刚好在边界处。</p><p>如果 <code>r</code> 不是边界，假设上述字符串 <code>s</code> 长度不止 13，且以 <code>i=9</code> 为中心的回文字符串，有 <code>s[13]=s[5]=&#39;a&#39;</code>，此时会有 <code>s[1]=s[13]=&#39;a&#39;</code>，那么以 <code>i=7</code> 为中心的最长回文子串长度就变长了，不止是 5；如果 <code>s[13]≠&#39;a&#39;</code>，在此情况下刚好向右扩展 <code>r-i=12-9=3</code> 步。</p></blockquote><p>上面两种情况满足公式：</p><script type="math/tex; mode=display">P[i] = min(r-i, P[i'])</script><p>然后从 <code>i</code> 左右 <code>P[i]</code> 的位置处继续向两侧扩展即可，如果以 <code>i</code> 为中心的回文字符串的右边界超过了 <code>r</code>，则更新 <code>c</code> 为<code>i</code> ，更新 <code>r</code> 为 <code>i + P[i]</code>。实现的 python 代码如下<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://medium.com/hackernoon/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f">[3]</span></a></sup>：</p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(N)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        s = <span class="hljs-string">&quot;#&quot;</span> + <span class="hljs-string">&quot;#&quot;</span>.join(s) + <span class="hljs-string">&quot;#&quot;</span><br>        N = <span class="hljs-built_in">len</span>(s)<br>        P = [<span class="hljs-number">0</span>] * N<br>        c, r = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        max_len = <span class="hljs-number">0</span>        <span class="hljs-comment"># 最大回文子串长度</span><br>        start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>  <span class="hljs-comment"># 最大回文子串的起始和结束位置</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>            i_mirror = (<span class="hljs-number">2</span> * c) - i<br>            <br>            <span class="hljs-keyword">if</span> i &lt; r:<br>                P[i] = <span class="hljs-built_in">min</span>(r - i, P[i_mirror])<br>            <span class="hljs-comment"># 开始中心扩展</span><br>            a = i - (<span class="hljs-number">1</span> + P[i])<br>            b = i + (<span class="hljs-number">1</span> + P[i])<br>            P[i] = self.expand_length(s, a, b)<br>            <br>            <span class="hljs-comment"># 查看当前位置 i 中心扩展后，当前右边界是否超过之前的最大右边界</span><br>            <span class="hljs-comment"># 如果是，则更新最大回文子串的 c 和 r</span><br>            <span class="hljs-keyword">if</span> i + P[i] &gt; r:<br>                c = i<br>                r = i + P[i]<br>                <span class="hljs-comment"># 判断是否为更长的回文子串</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span>*P[i]+<span class="hljs-number">1</span>) &gt; max_len:<br>                    max_len = <span class="hljs-number">2</span> * P[i] + <span class="hljs-number">1</span><br>                    start = <span class="hljs-number">2</span> * c - r <br>                    end = r<br>        res = s[start: end+<span class="hljs-number">1</span>]<br>        res = <span class="hljs-string">&#x27;&#x27;</span> .join(res.split(<span class="hljs-string">&#x27;#&#x27;</span>))<br>        <span class="hljs-keyword">return</span> res<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expand_length</span>(<span class="hljs-params">self, s, i, j</span>):</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">while</span> i&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j&lt;n <span class="hljs-keyword">and</span> s[i]==s[j]:<br>            i -= <span class="hljs-number">1</span><br>            j += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 最大回文子串长度 L = (j-1) - (i+1) + 1 = j - i - 1</span><br>        <span class="hljs-comment"># 则需要向左向右扩展 P[i] = (L-1)//2</span><br>        L = j - i - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> (L-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cxyxiaowu.com/2665.html">https://www.cxyxiaowu.com/2665.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://medium.com/hackernoon/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f">https://medium.com/hackernoon/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数组</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全相关数据集</title>
    <link href="/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <url>/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h1><h2 id="DARPA"><a href="#DARPA" class="headerlink" title="DARPA"></a>DARPA</h2><p><strong>数据集简介</strong></p><p>DARPA 数据集是 1998 年美国国防部高级研究计划局（Defense Advanced Research Projects Agency，DARPA）在麻省理工学院进行的一个入侵检测评估项目生成的，它包含 1998、1999、2000 这 3个数据集，包括 5 种主要的攻击类型<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://archive.ll.mit.edu/ideval/docs/attackDB.html">[1]</span></a></sup>：Denial of Service（DoS）、User to Root（U2R）、Remote to Local（R2L）、Probes 和 Data。</p><p>DARPA 1998 包括审计日志数据和网络流量数据两个部分，审计日志数据使用 Sun 公司的 Basic Security Monitoring (BSM) 收集，网络流量数据使用 tcpdump 收集。数据集中每一行代表一个会话，每一个会话对应两台计算机之间单独的 TCP/IP 连接，一个 TCP 会话过程包括建立三次握手到关闭连接时最后收到的 FIN 和 ACK 数据包。每一个会话通过 5 元组唯一标识，此 5 元组即开始时间、源 IP、目的 IP、源端口、目的端口。数据集在模拟的入侵环境中收集：路由器内部网上有两个工作站，外部有一个工作站。</p><blockquote><p>内部工作站 IP 分别为 192.168.0.20 和 192.168.0.40，BSM 在 192.168.0.20 这台工作站上运行；外部工作站 IP 为 192.168.1.30</p></blockquote><p>下面展示了 tcpdump 的样本及对应的特征，收集的样本仅包括内部和外部工作站之间的 TCP/IP 连接，特征包括 <code>唯一会话索引，会话开始日期，会话开始时间，会话持续时间，服务名，源端口，目的端口，源IP，目的IP，会话攻击分数和攻击名</code>，其中 <code>会话攻击分数</code> 表示这个会话是攻击的可能性，分数越高则此会话是攻击的可能性越大，训练数据会将此特征设置为 1 或 0 明确此会话是否为攻击，测试数据则会将此特征设为 0。<code>攻击名</code> 表明了此会话的攻击，具体可查阅 <a href="https://archive.ll.mit.edu/ideval/docs/attacks.html">1998 Training Data Attack Schedule</a>。</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">Start</span>      Start                     Src   Dest Src         Dest         Attack<br>   <span class="hljs-attribute">Date</span>       Time     Duration  Serv   Port  Port IP          IP           Score Name<br><span class="hljs-attribute">1</span>  <span class="hljs-number">01</span>/<span class="hljs-number">27</span>/<span class="hljs-number">1998</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">23</span>  ftp    <span class="hljs-number">1755</span>  <span class="hljs-number">21</span>  <span class="hljs-number">192.168.1.30</span> <span class="hljs-number">192.168.0.20</span> <span class="hljs-number">0</span>.<span class="hljs-number">31</span> -<br><span class="hljs-attribute">2</span>  <span class="hljs-number">01</span>/<span class="hljs-number">27</span>/<span class="hljs-number">1998</span> <span class="hljs-number">05</span>:<span class="hljs-number">04</span>:<span class="hljs-number">43</span> <span class="hljs-number">67</span>:<span class="hljs-number">59</span>:<span class="hljs-number">01</span>  telnet <span class="hljs-number">1042</span>  <span class="hljs-number">23</span>  <span class="hljs-number">192.168.1.30</span> <span class="hljs-number">192.168.0.20</span> <span class="hljs-number">0</span>.<span class="hljs-number">42</span> -<br></code></pre></td></tr></table></figure><p>下面展示了 BSM 审计数据的样本和对应的特征，它的格式和 tcpdump 是相同的，但因为只有 1 台工作站上装了 BSM，所以 BSM 会话数会少于 tcpdump 收集到的会话数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">Start</span>       Start                     Src  Dest Src          Dest        Attack<br>   <span class="hljs-attribute">Date</span>        Time     Duration Serv    Port Port IP           IP          Score Name<br><span class="hljs-attribute">1</span>  <span class="hljs-number">01</span>/<span class="hljs-number">27</span>/<span class="hljs-number">1998</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">22</span>  ftp    <span class="hljs-number">1755</span> <span class="hljs-number">21</span>  <span class="hljs-number">192.168.1.30</span> <span class="hljs-number">192.168.0.20</span> <span class="hljs-number">1</span>.<span class="hljs-number">13</span> -<br><span class="hljs-attribute">2</span>  <span class="hljs-number">01</span>/<span class="hljs-number">27</span>/<span class="hljs-number">1998</span> <span class="hljs-number">05</span>:<span class="hljs-number">05</span>:<span class="hljs-number">03</span> <span class="hljs-number">67</span>:<span class="hljs-number">59</span>:<span class="hljs-number">00</span>  telnet <span class="hljs-number">1042</span> <span class="hljs-number">23</span>  <span class="hljs-number">192.168.1.30</span> <span class="hljs-number">192.168.0.20</span> <span class="hljs-number">25</span>.<span class="hljs-number">0</span> guess<br></code></pre></td></tr></table></figure><p>DARPA 1999<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Lippmann, Richard, et al. “The 1999 DARPA off-line intrusion detection evaluation.” Computer networks 34.4 (2000): 579-595.">[2]</span></a></sup>/2000<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="杨怡, 边媛, 张天桥. 基于机器学习的网络安全态势感知[J]. 计算机科学与应用, 2020, 10(12): 2431-2438.">[3]</span></a></sup> 与 DARPA 1998 相比，除新增了一些攻击之外，最大的不同在于增加了一个 Windows NT 工作站作为受害者，因此数据集还多了 Windows NT 的审计数据，没有像 DARPA 1998 那样提供了 tcpdump.list 这样已经处理好的文本文件，需要自己解析，比如想获取 Snort 的告警日志，在安装和配置好 Snort 之后，可通过执行以下命令实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">snort -c ./Snort/snort.conf -r ./DARPA1999/inside.tcpdump -l ./Snort/<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>这两个数据集的相关介绍可以参考下面三篇文章：</p><ul><li><p><a href="https://blog.csdn.net/qq_36165570/article/details/104575813">DARPA2000超详细数据介绍</a></p></li><li><p><a href="https://www.jianshu.com/p/320178fca13c">Snort安装教程 &amp; DARPA1999、DARPA2000数据处理方法</a></p></li><li><a href="https://pdf.hanspub.org/CSA20201200000_25359476.pdf">基于机器学习的网络安全态势感知</a></li></ul><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="https://www.ll.mit.edu/r-d/datasets/1998-darpa-intrusion-detection-evaluation-dataset">https://www.ll.mit.edu/r-d/datasets/1998-darpa-intrusion-detection-evaluation-dataset</a></p><p><a href="https://www.ll.mit.edu/r-d/datasets/1999-darpa-intrusion-detection-evaluation-dataset">https://www.ll.mit.edu/r-d/datasets/1999-darpa-intrusion-detection-evaluation-dataset</a></p><p><a href="https://www.ll.mit.edu/r-d/datasets/2000-darpa-intrusion-detection-scenario-specific-datasets">https://www.ll.mit.edu/r-d/datasets/2000-darpa-intrusion-detection-scenario-specific-datasets</a></p><h2 id="KDD99"><a href="#KDD99" class="headerlink" title="KDD99"></a>KDD99</h2><p><strong>数据集简介</strong></p><p>KDD99 数据集<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://kdd.ics.uci.edu/databases/kddcup99/task.html">[4]</span></a></sup>基于 DARPA 1998 数据集，它对 DARPA 1998 数据集进行了特征分析和数据预处理。KDD99 将攻击分成了 4 大类，分别是 DoS、R2L、U2R 和 Probing。下面展示了 1 条 KDD99 的样本，它有 42 个字段，其中包括 41 项特征，最后 1 项是标签。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>,tcp,http,SF,<span class="hljs-number">181</span>,<span class="hljs-number">5450</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">1</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">11</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,normal.<br></code></pre></td></tr></table></figure><p>这 41 个特征又可以分成 3 类<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://kdd.ics.uci.edu/databases/kddcup99/task.html">[4]</span></a></sup>，基于 TCP 连接的基本特征、基于 TCP 连接内容的特征、基于时间的网络流量特征（这里使用 2 秒的窗口），具体内容可查阅 <a href="http://kdd.ics.uci.edu/databases/kddcup99/task.html">KDD-CUP-99 Task Description</a>。</p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html">http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html</a></p><h2 id="NSL-KDD"><a href="#NSL-KDD" class="headerlink" title="NSL-KDD"></a>NSL-KDD</h2><p><strong>数据集简介</strong></p><p>NSL-KDD<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="翟明芳, 张兴明, 赵博. 基于深度学习的加密恶意流量检测研究[J]. 网络与信息安全学报, 2020, 6(03): 66-77.">[5]</span></a></sup> 数据集去除 KDD99 数据集中冗余的数据，克服了分类器偏向于重复出现的记录等问题，需要填写一些个人信息，提交表单后才能获得数据集。</p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="https://www.unb.ca/cic/datasets/nsl.html">https://www.unb.ca/cic/datasets/nsl.html</a></p><h2 id="UNSW-NB-15"><a href="#UNSW-NB-15" class="headerlink" title="UNSW-NB 15"></a>UNSW-NB 15</h2><p><strong>数据集简介</strong></p><p>KDD99 等数据集距离现在已经十分久远，不能反映当前的网络威胁环境，所以新南威尔士大学（The University of New South Wales）创造了此数据集。UNSW_NB15_training-set.csv 和 UNSW_NB15_testing-set.csv 是预处理过的数据集，训练集有 175341 个样本，测试集有 82332 个样本。</p><p>下图给出了 UNSW-NB 15 没有预处理过的 CSV 数据集，它有 49 个字段，其中包括 2 个标签，最后两个字段分别为<code>attack_type</code> 和 <code>label</code> ，<code>attack_type</code> 用字符串的形式标识此记录的攻击类型，<code>label</code> 以 0-1 的方式标识此记录是否为攻击，攻击则此字段为 1，否则为 0，具体的每个字段的内容可以查看 UNSW-NB15_features.csv，或者阅读文献 <em>UNSW-NB15: a comprehensive data set for network intrusion detection systems (UNSW-NB15 network data set)</em><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="Moustafa, Nour, and Jill Slay. “UNSW-NB15: a comprehensive data set for network intrusion detection systems (UNSW-NB15 network data set).” 2015 military communications and information systems conference (MilCIS). IEEE, 2015.">[6]</span></a></sup>。</p><p><img src="/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/image-20210605213417521.png" alt="image-20210605213417521" style="zoom:50%;"></p><p>下图给出了 UNSW-NB 15 数据集的文件内容（UNSW_NB15_training-set.csv 和 UNSW_NB15_testing-set.csv），它有 45 个字段，其中包括 2 个标签，<code>attack_type</code> 和 <code>label</code> 。</p><p><img src="/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/image-20210605212229333.png" alt="image-20210605212229333" style="zoom:50%;"></p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p>项目地址：<a href="https://research.unsw.edu.au/projects/unsw-nb15-dataset">https://research.unsw.edu.au/projects/unsw-nb15-dataset</a></p><p>数据集下载：<a href="https://cloudstor.aarnet.edu.au/plus/index.php/s/2DhnLGDdEECo4ys">https://cloudstor.aarnet.edu.au/plus/index.php/s/2DhnLGDdEECo4ys</a></p><p>项目地址依然可以访问，但是数据集不能正常下载，需要到下面的 cloudstor 中下载。</p><h2 id="UGR’16"><a href="#UGR’16" class="headerlink" title="UGR’16"></a>UGR’16</h2><p><strong>数据集简介</strong></p><p>收集了西班牙一些具有战略性地位的 ISP 网络中的流量，它由两个不同的数据集组成：，一个从收集了 2016 年 3月到 2016 年 6 月 这 4 个月的校准数据集，它包含真正的后台业务数据； 还有一个收集了 2016 年 7 月到 2016 年 8 月这 2 个月的测试数据集，它包含真实数据和生成的流量数据，这些生成的数据覆盖了许多已知的攻击类型。</p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://nesg.ugr.es/nesg-ugr16/index.php">https://nesg.ugr.es/nesg-ugr16/index.php</a></p><h1 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h1><h2 id="CTU-13"><a href="#CTU-13" class="headerlink" title="CTU-13"></a>CTU-13</h2><p><strong>数据集简介</strong></p><p>CTU-13 是 2011 年在捷克理工大学（Czech Technical University in Prague）捕获的僵尸网络流量数据集。CTU-13 数据集包含 13 个不同场景下捕获到的数据，在每个场景中，我们都执行了一个特定的恶意软件，这个恶意软件使用了多种协议并执行了不同的操作，详细内容请查阅 <a href="https://mcfp.weebly.com/the-ctu-13-dataset-a-labeled-dataset-with-botnet-normal-and-background-traffic.html">THE CTU-13 DATASET. A LABELED DATASET WITH BOTNET, NORMAL AND BACKGROUND TRAFFIC.</a>。</p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://mcfp.weebly.com/the-ctu-13-dataset-a-labeled-dataset-with-botnet-normal-and-background-traffic.html">https://mcfp.weebly.com/the-ctu-13-dataset-a-labeled-dataset-with-botnet-normal-and-background-traffic.html</a></p><h1 id="WEB-攻击"><a href="#WEB-攻击" class="headerlink" title="WEB 攻击"></a>WEB 攻击</h1><h2 id="HTTP-CSIC-2010"><a href="#HTTP-CSIC-2010" class="headerlink" title="HTTP CSIC 2010"></a>HTTP CSIC 2010</h2><p><strong>数据集简介</strong></p><p>CSIC 2010 西班牙国家研究委员会信息安全研究所（Consejo Superior de Investigaciones Científicas）开发，包含 36000 个正常请求和 25000 多个异常请求，包括但不限于 SQL 注入、信息收集、敏感文件泄露 和 XSS 等 WEB 攻击。</p><p>下图给出了 CSIC 2010 数据集的文件内容，这是 2 个 SQL 注入的 HTTP 请求样本，CSIC 2010 的样本都是这样的 HTTP 请求，请求方法包括主要是 GET 和 POST，还有少量 PUT 请求。</p><p><img src="/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/image-20210605205632632.png" alt="image-20210605205632632" style="zoom:50%;"></p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="https://www.tic.itefi.csic.es/dataset/">https://www.tic.itefi.csic.es/dataset/</a></p><h1 id="垃圾邮件-amp-垃圾短信"><a href="#垃圾邮件-amp-垃圾短信" class="headerlink" title="垃圾邮件&amp;垃圾短信"></a>垃圾邮件&amp;垃圾短信</h1><h2 id="UCI-Spambase"><a href="#UCI-Spambase" class="headerlink" title="UCI Spambase"></a>UCI Spambase</h2><p><strong>数据集简介</strong></p><p>加州大学尔湾分校（Irvine, CA: University of California）收集的垃圾邮件数据集，它有 4601 个样本。</p><p>下面是 UCI Spambase 的一个样本，它有 58 个字段，包括 57 个特征和 1 个标签，最后一列是标签，0 代表该样本不是垃圾邮件，1 代表该样本是垃圾邮件。特征的具体说明可以查阅 <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/spambase/spambase.names">spambase.names</a>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">64</span>,<span class="hljs-number">0</span>.<span class="hljs-number">64</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">32</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">64</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">32</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>.<span class="hljs-number">29</span>,<span class="hljs-number">1</span>.<span class="hljs-number">93</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">96</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">778</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>.<span class="hljs-number">756</span>,<span class="hljs-number">61</span>,<span class="hljs-number">278</span>,<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="https://archive.ics.uci.edu/ml/datasets/Spambase">https://archive.ics.uci.edu/ml/datasets/Spambase</a></p><h2 id="UCI-SMS-Spam"><a href="#UCI-SMS-Spam" class="headerlink" title="UCI SMS Spam"></a>UCI SMS Spam</h2><p><strong>数据集简介</strong></p><p>加州大学尔湾分校收集的垃圾短信数据集，它有 5574 个样本，每个样本由 2 部分组成，第 1 部分是标签，第 2 部分是短信内容。</p><p>下面是此数据集的 2 个样本示例，标签和短信内容由制表符 <code>\t</code> 分隔，spam 代表这是一条垃圾短信，ham 代表这一条不是垃圾短信。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ham</span>Ok lar... Joking wif u oni...<br><span class="hljs-attribute">spam</span>Free entry in <span class="hljs-number">2</span> a wkly comp to win FA Cup final tkts <span class="hljs-number">21</span>st May <span class="hljs-number">2005</span>. Text FA to <span class="hljs-number">87121</span> to receive entry question(std txt rate)T&amp;C&#x27;s apply <span class="hljs-number">08452810075</span>over<span class="hljs-number">18</span>&#x27;s<br></code></pre></td></tr></table></figure><p><strong>数据集获取</strong></p><blockquote><p> 本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection">https://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection</a></p><h1 id="钓鱼网站-amp-钓鱼邮件"><a href="#钓鱼网站-amp-钓鱼邮件" class="headerlink" title="钓鱼网站&amp;钓鱼邮件"></a>钓鱼网站&amp;钓鱼邮件</h1><h2 id="UCI-Website-Phishing-Data-Set"><a href="#UCI-Website-Phishing-Data-Set" class="headerlink" title="UCI Website Phishing Data Set"></a>UCI Website Phishing Data Set</h2><p><strong>数据集简介</strong></p><p>加州大学尔湾分校收集的钓鱼网站数据集，它有 1353 个样本。</p><p>下面是此数据集的 2 个样本示例，它有 10 个字段，其中包括 9 个特征和 1 个标签。最后一个字段代表标签，它有 3 个可取值 <code>&#123;1,0,-1&#125;</code>，1 代表合法，0 代表可疑，说明它可能是钓鱼网站，也可能不是钓鱼网站，-1 代表钓鱼网站。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">1,<span class="hljs-string">-1</span>,1,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,1,1,1,0,0<br><span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,0,1,1,1,1<br></code></pre></td></tr></table></figure><p>这 9 个特征分别是 <code>SFH, popUpWidnow, SSLfinal_State, Request_URL, URL_of_Anchor, web_traffic, URL_Length, age_of_domain 和 having_IP_Address</code> ，特征的具体含义和取值算法阅读文献 <em>Phishing Detection based Associative Classification Data Mining</em>，比如 SFH 是 Server Form Handler 的缩写<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="Abdelhamid, Neda, Aladdin Ayesh, and Fadi Thabtah. “Phishing detection based associative classification data mining.” Expert Systems with Applications 41.13 (2014): 5948-5959.">[7]</span></a></sup>，URL_Length 就是 URL 的长度，如果长度小于 54 则为 1，代表合法网站，长度在 <code>[54,74]</code> 之间代表可疑网站，长度大于 74 则代表是钓鱼网站，取值为 -1。</p><p><strong>数据集获取</strong></p><blockquote><p> 本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://archive.ics.uci.edu/ml/datasets/Website+Phishing">https://archive.ics.uci.edu/ml/datasets/Website+Phishing</a></p><h2 id="Phishing-Features-Dataset"><a href="#Phishing-Features-Dataset" class="headerlink" title="Phishing Features Dataset"></a>Phishing Features Dataset</h2><p><strong>数据集简介</strong></p><p>马来西亚砂拉越大学计算机科学与信息技术学院<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="Chiew, Kang Leng, et al. “A new hybrid ensemble feature selection framework for machine learning-based phishing detection system.” Information Sciences 484 (2019): 153-166.">[8]</span></a></sup>制作的一个数据集，数据集从 2015 年 1 月至 2017 年 5 月收集了钓鱼网页和合法网页， 5000 个钓鱼网页和 5000 个合法网页，从 PhishTank 和 OpenPhish 的 URL 中选择了 5000 个钓鱼网页，还有 5000 个来自 Alexa 和 Common Crawl 存档的合法网页的 URL。</p><p>下面是此数据集的样本示例，包括 49 个字段，其中 48 项是特征，最后 1 项是标签。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">72</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">21</span>,<span class="hljs-number">44</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">0000000000</span>,<span class="hljs-number">0</span>.<span class="hljs-number">2500000000</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">0000000000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>数据集获取</strong></p><blockquote><p> 本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://data.mendeley.com/datasets/h3cgnj8hft/1">https://data.mendeley.com/datasets/h3cgnj8hft/1</a></p><h1 id="DGA"><a href="#DGA" class="headerlink" title="DGA"></a>DGA</h1><h2 id="360-DGA"><a href="#360-DGA" class="headerlink" title="360 DGA"></a>360 DGA</h2><p><strong>数据集简介</strong></p><p>360 提供的 DGA 数据集，全是恶意样本。</p><p>下面是此数据集的样本示例，包括 4 个字段，分别是 <code>所属DGA家族,域名,有效的开始时间,有效的结束时间</code>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nymaim</span>uvegpylvsj.net<span class="hljs-number">2021</span>-<span class="hljs-number">06</span>-<span class="hljs-number">08</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-number">2021</span>-<span class="hljs-number">06</span>-<span class="hljs-number">08</span> <span class="hljs-number">23</span>:<span class="hljs-number">59</span>:<span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-08</p></blockquote><p><a href="http://data.netlab.360.com/dga/">http://data.netlab.360.com/dga/</a></p><h1 id="数据集仓库"><a href="#数据集仓库" class="headerlink" title="数据集仓库"></a>数据集仓库</h1><h2 id="加拿大安全研究所"><a href="#加拿大安全研究所" class="headerlink" title="加拿大安全研究所"></a>加拿大安全研究所</h2><p>需要填写一些个人信息，提交表单后才能获得数据集。</p><blockquote><p>本文最后访问页面时间：2021-06-05</p></blockquote><p><a href="https://www.unb.ca/cic/datasets/index.html">https://www.unb.ca/cic/datasets/index.html</a></p><h2 id="SecRepo"><a href="#SecRepo" class="headerlink" title="SecRepo"></a>SecRepo</h2><blockquote><p>本文最后访问页面时间：2021-06-05</p></blockquote><p><a href="http://www.secrepo.com/">http://www.secrepo.com/</a></p><h2 id="CAIDA-Data"><a href="#CAIDA-Data" class="headerlink" title="CAIDA Data"></a>CAIDA Data</h2><blockquote><p>本文最后访问页面时间：2021-06-06</p></blockquote><p><a href="https://www.caida.org/catalog/datasets/overview/">https://www.caida.org/catalog/datasets/overview/</a></p><h2 id="Security-amp-Privacy-Laboratory"><a href="#Security-amp-Privacy-Laboratory" class="headerlink" title="Security &amp; Privacy Laboratory"></a>Security &amp; Privacy Laboratory</h2><blockquote><p>本文最后访问页面时间：2021-06-06</p></blockquote><p><a href="https://secplab.ppgia.pucpr.br/?q=trabid">https://secplab.ppgia.pucpr.br/?q=trabid</a></p><h2 id="Jason-Trost-博客"><a href="#Jason-Trost-博客" class="headerlink" title="Jason Trost 博客"></a>Jason Trost 博客</h2><p>这是汇丰银行网络安全分析引擎主管的博客网站，分享了一些数据集的地址</p><blockquote><p>本文最后访问页面时间：2021-06-06</p></blockquote><p><a href="http://www.covert.io/data-links/">http://www.covert.io/data-links/</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://archive.ll.mit.edu/ideval/docs/attackDB.html">https://archive.ll.mit.edu/ideval/docs/attackDB.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Lippmann, Richard, et al. “The 1999 DARPA off-line intrusion detection evaluation.” Computer networks 34.4 (2000): 579-595.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>杨怡, 边媛, 张天桥. 基于机器学习的网络安全态势感知[J]. 计算机科学与应用, 2020, 10(12): 2431-2438.<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="http://kdd.ics.uci.edu/databases/kddcup99/task.html">http://kdd.ics.uci.edu/databases/kddcup99/task.html</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>翟明芳, 张兴明, 赵博. 基于深度学习的加密恶意流量检测研究[J]. 网络与信息安全学报, 2020, 6(03): 66-77.<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>Moustafa, Nour, and Jill Slay. “UNSW-NB15: a comprehensive data set for network intrusion detection systems (UNSW-NB15 network data set).” 2015 military communications and information systems conference (MilCIS). IEEE, 2015.<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>Abdelhamid, Neda, Aladdin Ayesh, and Fadi Thabtah. “Phishing detection based associative classification data mining.” <em>Expert Systems with Applications</em> 41.13 (2014): 5948-5959.<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>Chiew, Kang Leng, et al. “A new hybrid ensemble feature selection framework for machine learning-based phishing detection system.” <em>Information Sciences</em> 484 (2019): 153-166.<a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>数据集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
      <tag>数据集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 寻找两个正序数组的中位数</title>
    <link href="/2021/05/31/LeetCode/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2021/05/31/LeetCode/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p></blockquote><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0.00000</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = []<br>输出：<span class="hljs-number">2.00000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>最简单的做法就是，合并两个数组，然后进行排序，取出中位数即可。</p><p>需要注意的是奇数长度和偶数长度的数组，中位数的取法不同。</p><p><img src="/2021/05/31/LeetCode/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/04-01.svg" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>        nums = nums1 + nums2<br>        nums.sort()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>:<br>            mid = <span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> nums[mid]<br>        <span class="hljs-keyword">else</span>:<br>            mid_2 = <span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span><br>            mid_1 = mid_2 - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> (nums[mid_1] + nums[mid_2])/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="利用二分法"><a href="#利用二分法" class="headerlink" title="利用二分法"></a>利用二分法</h2><p>题目希望我们以 $O(log(M+N))$ 的时间复杂度解决此题，<code>log</code> 的时间复杂度，加上两个数组已经是正序的，这可以联想到二分法，因此考虑用二分法解决此题。</p><p>根据第一种解法，设合并后的数组长度为 <code>L</code>，奇数长度的数组中位数是第 <code>L//2 + 1</code> 个数字，偶数长度的数组中位数是第 <code>L//2</code> 和 <code>L//2 +1</code>，其实相当于寻找第 <code>k</code> 小的数字<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="LeetCode 官方题解：寻找两个有序数组的中位数">[1]</span></a></sup>，<code>k</code> 是 <code>L//2</code> 或 <code>L//2 + 1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>        m, n = <span class="hljs-built_in">len</span>(nums1), <span class="hljs-built_in">len</span>(nums2)<br>        k = (m+n) // <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (m+n)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, k)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> (findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, k-<span class="hljs-number">1</span>) + findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, k))/<span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKth</span>(<span class="hljs-params">nums1, start1, nums2, start2, k</span>):</span><br>    <span class="hljs-keyword">if</span> start1==<span class="hljs-built_in">len</span>(nums1):<br>        <span class="hljs-comment"># 排除了 nums1 的所有元素</span><br>        <span class="hljs-keyword">return</span> nums2[start2 + k - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">elif</span> start2==<span class="hljs-built_in">len</span>(nums2):<br>        <span class="hljs-comment"># 排除了nums2 的所有元素</span><br>        <span class="hljs-keyword">return</span> nums1[start1 + k - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">elif</span> k==<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[start1], nums2[start2])<br>    i = start1 + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(nums1), k//<span class="hljs-number">2</span>) - <span class="hljs-number">1</span><br>    j = start2 + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(nums2), k//<span class="hljs-number">2</span>) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums1[i] &lt; nums2[j]:<br>        k = k - (i - start1 + <span class="hljs-number">1</span>)<br>        start1 = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> findKth(nums1, start1, nums2, start2, k)<br>    <span class="hljs-keyword">else</span>:<br>        k = k - (j - start2 + <span class="hljs-number">1</span>)<br>        start2 = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> findKth(nums1, start1, nums2, start2, k)<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">LeetCode 官方题解：寻找两个有序数组的中位数</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数组</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p></blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;&quot;</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题可以用双指针来做，这里以查找字符串 <code>&quot;abcbb&quot;</code> 为例，查看一下大致的流程</p><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-01.svg" alt></p><blockquote><p>一开始，我们初始化最大长度、当前结果和当前长度、左右指针。当前结果用集合来存放，帮助我们快速判断是否存在重复字符</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-02.svg" alt></p><blockquote><p>首先，左右指针均指向第一个字符，当前结果为 <code>&quot;a&quot;</code>，其长度大于最大长度 0，更新最大长度为 1</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-03.svg" alt></p><blockquote><p>右指针往右搜索，此时指向字符 <code>&quot;b&quot;</code>，字符 <code>&quot;b&quot;</code> 不在当前结果中，故当前结果为 <code>&quot;ab&quot;</code>，更新最大长度为 2</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-04.svg" alt></p><blockquote><p>右指针继续搜索，<code>&quot;c&quot;</code> 同样没有重复，更新最大长度为 3</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-05.svg" alt></p><blockquote><p>右指针再往右时指向了字符 <code>&quot;b&quot;</code>，而 <code>&quot;b&quot;</code> 是一个重复字符，这时需要让左指针往右移动，直到当前子串中没有重复字符</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-06.svg" alt></p><blockquote><p>左指针指向下一个字符，此时子串为 <code>&quot;bcb&quot;</code>，仍有重复字符 <code>&quot;b&quot;</code>，左指针还需要继续往右移动</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-07.svg" alt></p><blockquote><p>此时子串为 <code>&quot;cb&quot;</code>，没有重复字符，但是长度为 2，不更新最大长度</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-08.svg" alt></p><blockquote><p>右指针往右，此时子串为 <code>&quot;cbb&quot;</code>，出现重复字符 <code>&quot;b&quot;</code>，右移左指针</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-09.svg" alt></p><blockquote><p>左指针不断右移，直到子串没有重复的字符，在我们的例子中，这时 <code>left=right=4</code>，子串为 <code>&quot;b&quot;</code>，不更新最大长度。</p><p>此时已经遍历完整个字符串，输出我们记录的最大长度即可。</p></blockquote><p>如果用文字表示上图的流程，大致为：</p><ul><li>初始化所需的变量；</li><li>遍历字符串 <code>s</code> 中的每个字符；<ul><li>如果 <code>left</code> 和 <code>right</code> 截取的子串没有重复的字符，更新当前的子串，如果当前子串长度大于最大长度，则更新最大长度；</li><li>如果 <code>right</code> 指向的字符出现了重复，则 <code>left</code> 往右增长，直到当前子串中没有重复的字符，更新当前子串，如果当前子串的长度大于最大长度，则更新最大长度。</li></ul></li><li>返回最大长度。</li></ul><p>根据上述流程，实现的 python 代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        max_len, cur_len = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        left = right = <span class="hljs-number">0</span><br>        lookup = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">while</span> s[right] <span class="hljs-keyword">in</span> lookup:<br>                lookup.remove(s[left])<br>                left += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            lookup.add(s[right])<br>            cur_len = <span class="hljs-built_in">len</span>(lookup)<br>            <span class="hljs-keyword">if</span> cur_len &gt; max_len:<br>                max_len = cur_len<br>        <span class="hljs-keyword">return</span> max_len<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 两数相加</title>
    <link href="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p></blockquote><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这里以 <code>22 + 79</code> 为例，我们看一下大致的流程</p><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-00.svg" alt></p><blockquote><p><code>22+79=101</code>，我们的链表逆序存储，返回的结果应为 <code>1 → 0 → 1</code></p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-01.svg" alt></p><blockquote><p>我们初始化一个链表，用来存放求和结果，这里设置了两个指针 <code>dummy</code> 和 <code>head</code>，其中 <code>head</code> 跟随着计算结果不断指向链表尾部，<code>dummy</code> 一直指向初始化链表的头部，最后返回 <code>dummy.next</code> 就可以得到所求的链表</p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-02.svg" alt></p><blockquote><p>首先是个位相加，得到结果 11，所以个位求和后，进位为1，本位也为 1，因此 <code>head</code> 的下一个结点存放本位的结果 1。</p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-03.svg" alt></p><blockquote><p>上一步个位求和结果有进位 1，因此这里要求和的是 <code>1+2+7=10</code>，即进位为1，本位为 0。 <code>head</code> 的下一个结点存放本位的结果 0</p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-04.svg" alt></p><blockquote><p>上一步进行十位求和的结果中有一个进位 1，所以我们还需要继续计算下去，但是一开始求和的是两位数 22 和 79，存放这两个数值的链表取到百位的时候是 <code>None</code>，<code>None</code> 是没有属性 <code>val</code>，因此计算时要把 <code>val</code> 赋为 0。最后计算得到 <code>1</code>，本位为 1，进位为 0。</p><p><code>head</code> 的下一个结点存放本位的结果 1，这时候 <code>dummy</code> 指向的是初始化的头结点，返回 <code>dummy.next</code> 才是所求的链表</p></blockquote><p>图中的流程大致可以用文字描述为：</p><ul><li>初始化一个存放结果的链表 <code>head</code>，初始化进位 <code>c</code> 为0；</li><li>如果 <code>l1</code> 或 <code>l2</code> 非空或者 <code>c</code> 非 0<ul><li>进行求和；如果 <code>l1</code> 非空，则取出 <code>l1</code> 中存放的值 <code>v_1</code>，若 <code>l1</code> 为空则设 <code>v_1</code> 为 0，<code>l2</code> 同理；</li><li>求和，<code>sum = c + v_1 + v_2</code>，计算进位 <code>c = sum //10</code>，链表下一个结点存放的值为本位 <code>head.next = ListNode(sum % 10)</code>；</li><li><code>head</code> 移动后链表尾部，<code>l1</code> 移动到下一个结点，如果 <code>l1</code> 为空则继续为设空，<code>l2</code> 同理。</li></ul></li><li>流程结束，返回 <code>dummy.next</code> 得到结果。</li></ul><p>根据上述流程，实现的 python 代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br>        dummy = head = ListNode()<br>        c = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> c:<br>            v_1 = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            v_2 = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-built_in">sum</span> = c + v_1 + v_2<br>            c = <span class="hljs-built_in">sum</span> // <span class="hljs-number">10</span><br>            head.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-built_in">sum</span> % <span class="hljs-number">10</span>)<br>            head = head.<span class="hljs-built_in">next</span><br>            l1 = l1.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>            l2 = l2.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 两数之和</title>
    <link href="/2021/05/22/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/05/22/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a></p></blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 103</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>利用两个 <code>for</code> 循环，找到求和等于 <code>target</code> 的数字下标即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,n):<br>                <span class="hljs-keyword">if</span> nums[i]+nums[j]==target:<br>                    <span class="hljs-keyword">return</span> [i,j]<br></code></pre></td></tr></table></figure><h2 id="利用字典"><a href="#利用字典" class="headerlink" title="利用字典"></a>利用字典</h2><p>两个 <code>for</code> 循环的时间复杂度为 $O(N^2)$，如果我们用字典记录之前看过的数字和对应的索引，遍历其他数字时，先计算该数字和 <code>target</code> 的差值 <code>diff=target-num</code>，如果 <code>diff</code> 在字典中，我们就能直接返回结果，而字典的查找时间复杂度为 <code>O(1)</code>，整个算法的时间复杂度降到 $O(N)$。流程如下：</p><ul><li>初始化一个字典；</li><li>开始遍历 <code>nums</code> 中的数字 <code>num</code>，计算 <code>diff=target-num</code> ，如果 <code>diff</code> 在字典中，结束流程，返回数字下标；如果 <code>diff</code> 不在字典中，我们在字典中添加一个元素，键为 <code>num</code>，值为 <code>num</code> 的下标；</li><li>不断重复此过程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        lookup = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            diff = target - num<br>            <span class="hljs-keyword">if</span> diff <span class="hljs-keyword">in</span> lookup:<br>                <span class="hljs-keyword">return</span> [lookup[diff],i]<br>            <span class="hljs-keyword">else</span>:<br>                lookup[num] = i<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>算法简介</strong></p><p>二分查找是在<strong>有序数组</strong>中寻找某一元素的查找算法，它的主要思想就是将搜索空间缩小为原来的一半。尽管二分查找的思想非常简单，但是很多人也容易出错，主要问题出现在代码对边界值的处理、比较符号带不带等号这些细节上。</p><p><strong>算法流程</strong></p><ul><li>设数组 <code>arr = [0, 1, …, N]</code>，初始化左边界 <code>left=0</code>，右边界 <code>right=len(arr)-1</code>，<code>mid</code> 为左右指针的中点；</li><li>取出 <code>mid</code> 指向的元素，如果此元素为查找的元素，结束查找过程，并返回结果；</li><li>如果 <code>mid</code> 指向的元素大于查找目标，因为数组有序，因此接下来查找 <code>arr[left, mid-1]</code>；如果此元素小于查找目标，那么接下来查找 <code>arr[mid+1, right]</code>；</li><li>更新 <code>left</code>、<code>right</code> 和 <code>mid</code>，不断重复此过程，如果搜索空间为空，说明数组 <code>arr</code> 中不存在所要寻找的值。</li></ul><p><strong>复杂度分析</strong></p><ul><li>平均时间复杂度 $O(\log N)$</li><li>最坏时间复杂度 $O(\log N)$</li><li>空间复杂度<ul><li>迭代实现： $O(1)$</li><li>递归实现： $O(\log N)$</li></ul></li></ul><h1 id="基本的二分查找"><a href="#基本的二分查找" class="headerlink" title="基本的二分查找"></a>基本的二分查找</h1><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210428231629222.svg" alt></p><blockquote><p>一开始 7 小于 11，下一步需要缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215308600.svg" alt></p><blockquote><p>14 大于 11，在上一步的基础上，缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215338299.svg" alt></p><blockquote><p>找到 11 所在的索引，返回索引值 3</p></blockquote><p>如上图所示，给定数组 <code>arr=[2,4,7,11,14,27]</code> 和 <code>target=11</code> 的查找流程，可用文字描述为：</p><ul><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>进入二分查找的循环体中，结束循环的条件为 <code>left&lt;=right</code>；</p><ul><li>计算 mid，<code>mid=left+(right-left)//2</code>，可以看做向下取整，这里没使用 <code>(left+right)//2</code> ，因为 left 和 right 直接相加时可能会出现溢出的情况；</li><li>判断 <code>arr[mid]</code> 和目标值的大小关系，如果相等，则结束查找流程，返回 target 的索引，即 mid；</li><li>如果 <code>arr[mid]</code> 大于目标值，可以缩小搜索空间为 <code>[left, mid-1]</code> ，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 小于目标值，可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果满足循环的条件，则不断重复此过程。</li></ul></li><li>结束循环，如果没有找到目标值，返回 -1。</li></ul><blockquote><p>结束循环的条件是 <code>left&lt;=right</code>，即我们的搜索空间为 <code>[left, right]</code>，这是一个闭区间。当 <code>left=right</code> 时，搜索空间不为空，仍然需要继续搜索，比如数组 <code>arr=[66]</code> 和 <code>target=66</code>，此时有 <code>left=right=0</code>，搜索空间为闭区间 <code>[0, 0]</code> ，即搜索的数组下标只有 0；如果用了 <code>left&lt;right</code>，就成了半开半闭区间 <code>[0, 0)</code> ，此时是一个空集合，程序不能正确返回结果。</p></blockquote><p>根据上面的描述内容，采用迭代的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">arr, target</span>):</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = left + (right-left)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> arr[mid] == target:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">elif</span> arr[mid]&gt;target:<br>            right = mid-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left = mid+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>采用递归的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">arr, target, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>    left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> left<br>    right = <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> right<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">or</span> left&gt;right:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    mid = left + (right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> arr[mid]==target:<br>        <span class="hljs-keyword">return</span> mid<br>    <span class="hljs-keyword">elif</span> arr[mid]&gt;target:<br>        right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search(arr, target, left, right)<br>    <span class="hljs-keyword">else</span>:<br>        left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search(arr, target, left, right)<br></code></pre></td></tr></table></figure><h1 id="寻找最左边界"><a href="#寻找最左边界" class="headerlink" title="寻找最左边界"></a>寻找最左边界</h1><p><strong>我们先来看看所查找的元素在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215558742.svg" alt></p><blockquote><p>mid 指向的元素刚好是 target，我们要找最左边界，那么需要查看 mid 左边是否还有 4 这个元素，缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215608740.svg" alt></p><blockquote><p>mid 指向的元素2 小于 4，需要缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215621806.svg" alt></p><blockquote><p> 此时 mid 指向的元素刚好为 4，这是跟第一步一样，左边可能还存在元素 4，我们缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429220621111.svg" alt></p><blockquote><p>此时 right &lt; left，跳出循环体，left 指向的即为所查找目标的最左边界</p></blockquote><p><strong>我们再看看查找的目标值不在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221502600.svg" alt></p><blockquote><p>两个示例中，目标值均大于 4，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221537732.svg" alt></p><blockquote><p>示例 1 中 14 大于目标值 6，缩小搜索空间为左半部分；示例 2 中 14 小于目标值 30，继续缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221606076.svg" alt></p><blockquote><p>两个示例中 mid 指针所指元素均小于目标值，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221625527.svg" alt></p><blockquote><p>缩小搜索空间后，两个示例均有 right&lt;left ，结束循环。此时示例 1 的 left 指向的元素不为 6，而示例 2 的 left 超出数组边界</p></blockquote><p>二分查找的一个应用是寻找满足条件的最左边界，如果不存在则返回-1，上图的查找流程，可用文字描述为：</p><ul><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>进入二分查找的循环体中，结束循环的条件为 <code>left&lt;=right</code>；</p><ul><li>计算 mid，<code>mid=left+(right-left)//2</code>；</li><li>判断 <code>arr[mid]</code> 和目标值的大小关系，因为我们要找的是最左边界，如果相等，mid 的左边可能依然存在我们的目标值，我们可以缩小搜索空间为 <code>[left, mid-1]</code>，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 大于目标值，可以缩小搜索空间为 <code>[left, mid-1]</code> ，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 小于目标值，可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果满足循环的条件，则不断重复此过程。</li></ul></li><li>结束循环，如果没有找到目标值，返回 -1；</li><li>如果找到目标值，返回 left 即为最左边界。</li></ul><p>根据上面的描述内容，采用迭代的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_left</span>(<span class="hljs-params">arr, target</span>):</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = left + (right - left)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> arr[mid] &gt;= target:<br>            right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;<span class="hljs-built_in">len</span>(arr) <span class="hljs-keyword">or</span> arr[left]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure><p>采用递归的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_left</span>(<span class="hljs-params">arr, target, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>    left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> left<br>    right = <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> right<br>    mid = left + (right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">or</span> left&gt;<span class="hljs-built_in">len</span>(arr):<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[left]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[left]==target:<br>        <span class="hljs-keyword">return</span> left<br>    <span class="hljs-keyword">if</span> arr[mid] &gt;= target:<br>        right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_left(arr, target, left, right)<br>    <span class="hljs-keyword">else</span>:<br>        left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_left(arr, target, left, right)<br></code></pre></td></tr></table></figure><h1 id="寻找最右边界"><a href="#寻找最右边界" class="headerlink" title="寻找最右边界"></a>寻找最右边界</h1><p><strong>我们先来看看所查找的元素在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429223719914.svg" alt></p><blockquote><p>mid 指向的目标值刚好为 4，我们要找的是最右边界，因此需要寻找 mid 右边是否还有 4，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429223732516.svg" alt></p><blockquote><p>mid 指向的元素是 14，大于查找目标4，因此缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429223735600.svg" alt></p><blockquote><p>此时 mid 指向的元素刚好是 4，跟第一步一样，我们要查找 mid 右边是否还有元素 4，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224032037.svg" alt></p><blockquote><p>此时 right&lt;left，循环结束，right 指向的是查找目标的最右边界</p></blockquote><p><strong>我们再看看查找目标不在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224231519.svg" alt></p><blockquote><p>示例 1 中目标值 6 大于 4，缩小搜索空间为右半部分；示例 2 中目标值 1 小于 4，缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224623562.svg" alt></p><blockquote><p>示例 1 中目标值 6 小于 14，缩小搜索空间为左半部分；示例 2 中目标值 1 小于2，缩小搜索空间为左边部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224627809.svg" alt></p><blockquote><p>示例 1 中目标值 6 大于 14，搜小搜索空间为右半部分；示例 2 中 right &lt; 0 &lt; left，循环结束</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224840436.svg" alt></p><blockquote><p>示例 1 中 right&lt;left，循环结束，且 right 指向的元素不是目标值</p></blockquote><p>二分查找的另一个应用是寻找满足条件的最右边界，如果不存在则返回-1，上图的查找流程，可用文字描述为：</p><ul><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>进入二分查找的循环体中，结束循环的条件为 <code>left&lt;=right</code>；</p><ul><li>计算 mid，<code>mid=left+(right-left)//2</code>；</li><li>判断 <code>arr[mid]</code> 和目标值的大小关系，因为我们要找的是最左边界，如果相等，mid 的右边可能依然存在我们的目标值，我们可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果 <code>arr[mid]</code> 大于目标值，可以缩小搜索空间为 <code>[left, mid-1]</code> ，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 小于目标值，可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果满足循环的条件，则不断重复此过程。</li></ul></li><li>结束循环，如果没有找到目标值，返回 -1；</li><li>如果找到目标值，返回 right 即为最右边界。</li></ul><p>根据上面的描述内容，采用迭代的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_right</span>(<span class="hljs-params">arr, target</span>):</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = left + (right-left)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> arr[mid]&lt;=target:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> right&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> arr[right]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> right<br></code></pre></td></tr></table></figure><p>采用递归的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_right</span>(<span class="hljs-params">arr, target, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>    left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> left<br>    right = <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> right<br>    mid = left + (right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">or</span> right&lt;<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[right]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[right]==target:<br>        <span class="hljs-keyword">return</span> right<br>    <span class="hljs-keyword">if</span> arr[mid]&lt;=target:<br>        left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_right(arr, target, left, right)<br>    <span class="hljs-keyword">else</span>:<br>        right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_right(arr, target, left, right)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>查找</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>welcome</title>
    <link href="/2021/03/27/welcome/"/>
    <url>/2021/03/27/welcome/</url>
    
    <content type="html"><![CDATA[<p>兴趣使然的博客</p><p><img src="/2021/03/27/welcome/1.jpg" alt></p><script type="math/tex; mode=display">1.01^{365}=37.7834</script>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
