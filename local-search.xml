<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络安全相关数据集</title>
    <link href="/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <url>/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h1><h2 id="DARPA"><a href="#DARPA" class="headerlink" title="DARPA"></a>DARPA</h2><p><strong>数据集简介</strong></p><p>DARPA 数据集是 1998 年美国国防部高级研究计划局（Defense Advanced Research Projects Agency，DARPA）在麻省理工学院进行的一个入侵检测评估项目生成的，它包含 1998、1999、2000 这 3个数据集，包括 5 种主要的攻击类型<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://archive.ll.mit.edu/ideval/docs/attackDB.html">[1]</span></a></sup>：Denial of Service（DoS）、User to Root（U2R）、Remote to Local（R2L）、Probes 和 Data。</p><p>DARPA 1998 包括审计日志数据和网络流量数据两个部分，审计日志数据使用 Sun 公司的 Basic Security Monitoring (BSM) 收集，网络流量数据使用 tcpdump 收集。数据集中每一行代表一个会话，每一个会话对应两台计算机之间单独的 TCP/IP 连接，一个 TCP 会话过程包括建立三次握手到关闭连接时最后收到的 FIN 和 ACK 数据包。每一个会话通过 5 元组唯一标识，此 5 元组即开始时间、源 IP、目的 IP、源端口、目的端口。数据集在模拟的入侵环境中收集：路由器内部网上有两个工作站，外部有一个工作站。</p><blockquote><p>内部工作站 IP 分别为 192.168.0.20 和 192.168.0.40，BSM 在 192.168.0.20 这台工作站上运行；外部工作站 IP 为 192.168.1.30</p></blockquote><p>下面展示了 tcpdump 的样本及对应的特征，收集的样本仅包括内部和外部工作站之间的 TCP/IP 连接，特征包括 <code>唯一会话索引，会话开始日期，会话开始时间，会话持续时间，服务名，源端口，目的端口，源IP，目的IP，会话攻击分数和攻击名</code>，其中 <code>会话攻击分数</code> 表示这个会话是攻击的可能性，分数越高则此会话是攻击的可能性越大，训练数据会将此特征设置为 1 或 0 明确此会话是否为攻击，测试数据则会将此特征设为 0。<code>攻击名</code> 表明了此会话的攻击，具体可查阅 <a href="https://archive.ll.mit.edu/ideval/docs/attacks.html">1998 Training Data Attack Schedule</a>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">Start</span>      Start                     Src   Dest Src         Dest         Attack<br>   <span class="hljs-attribute">Date</span>       Time     Duration  Serv   Port  Port IP          IP           Score Name<br><span class="hljs-attribute">1</span>  <span class="hljs-number">01</span>/<span class="hljs-number">27</span>/<span class="hljs-number">1998</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">23</span>  ftp    <span class="hljs-number">1755</span>  <span class="hljs-number">21</span>  <span class="hljs-number">192.168.1.30</span> <span class="hljs-number">192.168.0.20</span> <span class="hljs-number">0</span>.<span class="hljs-number">31</span> -<br><span class="hljs-attribute">2</span>  <span class="hljs-number">01</span>/<span class="hljs-number">27</span>/<span class="hljs-number">1998</span> <span class="hljs-number">05</span>:<span class="hljs-number">04</span>:<span class="hljs-number">43</span> <span class="hljs-number">67</span>:<span class="hljs-number">59</span>:<span class="hljs-number">01</span>  telnet <span class="hljs-number">1042</span>  <span class="hljs-number">23</span>  <span class="hljs-number">192.168.1.30</span> <span class="hljs-number">192.168.0.20</span> <span class="hljs-number">0</span>.<span class="hljs-number">42</span> -<br></code></pre></td></tr></table></figure><p>下面展示了 BSM 审计数据的样本和对应的特征，它的格式和 tcpdump 是相同的，但因为只有 1 台工作站上装了 BSM，所以 BSM 会话数会少于 tcpdump 收集到的会话数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">Start</span>       Start                     Src  Dest Src          Dest        Attack<br>   <span class="hljs-attribute">Date</span>        Time     Duration Serv    Port Port IP           IP          Score Name<br><span class="hljs-attribute">1</span>  <span class="hljs-number">01</span>/<span class="hljs-number">27</span>/<span class="hljs-number">1998</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">22</span>  ftp    <span class="hljs-number">1755</span> <span class="hljs-number">21</span>  <span class="hljs-number">192.168.1.30</span> <span class="hljs-number">192.168.0.20</span> <span class="hljs-number">1</span>.<span class="hljs-number">13</span> -<br><span class="hljs-attribute">2</span>  <span class="hljs-number">01</span>/<span class="hljs-number">27</span>/<span class="hljs-number">1998</span> <span class="hljs-number">05</span>:<span class="hljs-number">05</span>:<span class="hljs-number">03</span> <span class="hljs-number">67</span>:<span class="hljs-number">59</span>:<span class="hljs-number">00</span>  telnet <span class="hljs-number">1042</span> <span class="hljs-number">23</span>  <span class="hljs-number">192.168.1.30</span> <span class="hljs-number">192.168.0.20</span> <span class="hljs-number">25</span>.<span class="hljs-number">0</span> guess<br></code></pre></td></tr></table></figure><p>DARPA 1999<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Lippmann, Richard, et al. “The 1999 DARPA off-line intrusion detection evaluation.” Computer networks 34.4 (2000): 579-595.">[2]</span></a></sup>/2000<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="杨怡, 边媛, 张天桥. 基于机器学习的网络安全态势感知[J]. 计算机科学与应用, 2020, 10(12): 2431-2438.">[3]</span></a></sup> 与 DARPA 1998 相比，除新增了一些攻击之外，最大的不同在于增加了一个 Windows NT 工作站作为受害者，因此数据集还多了 Windows NT 的审计数据，没有像 DARPA 1998 那样提供了 tcpdump.list 这样已经处理好的文本文件，需要自己解析，比如想获取 Snort 的告警日志，在安装和配置好 Snort 之后，可通过执行以下命令实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">snort -c ./Snort/snort.conf -r ./DARPA1999/inside.tcpdump -l ./Snort/<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>这两个数据集的相关介绍可以参考下面三篇文章：</p><ul><li><p><a href="https://blog.csdn.net/qq_36165570/article/details/104575813">DARPA2000超详细数据介绍</a></p></li><li><p><a href="https://www.jianshu.com/p/320178fca13c">Snort安装教程 &amp; DARPA1999、DARPA2000数据处理方法</a></p></li><li><a href="https://pdf.hanspub.org/CSA20201200000_25359476.pdf">基于机器学习的网络安全态势感知</a></li></ul><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="https://www.ll.mit.edu/r-d/datasets/1998-darpa-intrusion-detection-evaluation-dataset">https://www.ll.mit.edu/r-d/datasets/1998-darpa-intrusion-detection-evaluation-dataset</a></p><p><a href="https://www.ll.mit.edu/r-d/datasets/1999-darpa-intrusion-detection-evaluation-dataset">https://www.ll.mit.edu/r-d/datasets/1999-darpa-intrusion-detection-evaluation-dataset</a></p><p><a href="https://www.ll.mit.edu/r-d/datasets/2000-darpa-intrusion-detection-scenario-specific-datasets">https://www.ll.mit.edu/r-d/datasets/2000-darpa-intrusion-detection-scenario-specific-datasets</a></p><h2 id="KDD99"><a href="#KDD99" class="headerlink" title="KDD99"></a>KDD99</h2><p><strong>数据集简介</strong></p><p>KDD99 数据集<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://kdd.ics.uci.edu/databases/kddcup99/task.html">[4]</span></a></sup>基于 DARPA 1998 数据集，它对 DARPA 1998 数据集进行了特征分析和数据预处理。KDD99 将攻击分成了 4 大类，分别是 DoS、R2L、U2R 和 Probing。下面展示了 1 条 KDD99 的样本，它有 42 个字段，其中包括 41 项特征，最后 1 项是标签。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>,tcp,http,SF,<span class="hljs-number">181</span>,<span class="hljs-number">5450</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">1</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">11</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,<span class="hljs-number">0</span>.<span class="hljs-number">00</span>,normal.<br></code></pre></td></tr></table></figure><p>这 41 个特征又可以分成 3 类<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://kdd.ics.uci.edu/databases/kddcup99/task.html">[4]</span></a></sup>，基于 TCP 连接的基本特征、基于 TCP 连接内容的特征、基于时间的网络流量特征（这里使用 2 秒的窗口），具体内容可查阅 <a href="http://kdd.ics.uci.edu/databases/kddcup99/task.html">KDD-CUP-99 Task Description</a>。</p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html">http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html</a></p><h2 id="NSL-KDD"><a href="#NSL-KDD" class="headerlink" title="NSL-KDD"></a>NSL-KDD</h2><p><strong>数据集简介</strong></p><p>NSL-KDD<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="翟明芳, 张兴明, 赵博. 基于深度学习的加密恶意流量检测研究[J]. 网络与信息安全学报, 2020, 6(03): 66-77.">[5]</span></a></sup> 数据集去除 KDD99 数据集中冗余的数据，克服了分类器偏向于重复出现的记录等问题，需要填写一些个人信息，提交表单后才能获得数据集。</p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="https://www.unb.ca/cic/datasets/nsl.html">https://www.unb.ca/cic/datasets/nsl.html</a></p><h2 id="UNSW-NB-15"><a href="#UNSW-NB-15" class="headerlink" title="UNSW-NB 15"></a>UNSW-NB 15</h2><p><strong>数据集简介</strong></p><p>KDD99 等数据集距离现在已经十分久远，不能反映当前的网络威胁环境，所以新南威尔士大学（The University of New South Wales）创造了此数据集。UNSW_NB15_training-set.csv 和 UNSW_NB15_testing-set.csv 是预处理过的数据集，训练集有 175341 个样本，测试集有 82332 个样本。</p><p>下图给出了 UNSW-NB 15 没有预处理过的 CSV 数据集，它有 49 个字段，其中包括 2 个标签，最后两个字段分别为<code>attack_type</code> 和 <code>label</code> ，<code>attack_type</code> 用字符串的形式标识此记录的攻击类型，<code>label</code> 以 0-1 的方式标识此记录是否为攻击，攻击则此字段为 1，否则为 0，具体的每个字段的内容可以查看 UNSW-NB15_features.csv，或者阅读文献 <em>UNSW-NB15: a comprehensive data set for network intrusion detection systems (UNSW-NB15 network data set)</em><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="Moustafa, Nour, and Jill Slay. “UNSW-NB15: a comprehensive data set for network intrusion detection systems (UNSW-NB15 network data set).” 2015 military communications and information systems conference (MilCIS). IEEE, 2015.">[6]</span></a></sup>。</p><p><img src="/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/image-20210605213417521.png" alt="image-20210605213417521" style="zoom:50%;"></p><p>下图给出了 UNSW-NB 15 数据集的文件内容（UNSW_NB15_training-set.csv 和 UNSW_NB15_testing-set.csv），它有 45 个字段，其中包括 2 个标签，<code>attack_type</code> 和 <code>label</code> 。</p><p><img src="/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/image-20210605212229333.png" alt="image-20210605212229333" style="zoom:50%;"></p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p>项目地址：<a href="https://research.unsw.edu.au/projects/unsw-nb15-dataset">https://research.unsw.edu.au/projects/unsw-nb15-dataset</a></p><p>数据集下载：<a href="https://cloudstor.aarnet.edu.au/plus/index.php/s/2DhnLGDdEECo4ys">https://cloudstor.aarnet.edu.au/plus/index.php/s/2DhnLGDdEECo4ys</a></p><p>项目地址依然可以访问，但是数据集不能正常下载，需要到下面的 cloudstor 中下载。</p><h2 id="UGR’16"><a href="#UGR’16" class="headerlink" title="UGR’16"></a>UGR’16</h2><p><strong>数据集简介</strong></p><p>收集了西班牙一些具有战略性地位的 ISP 网络中的流量，它由两个不同的数据集组成：，一个从收集了 2016 年 3月到 2016 年 6 月 这 4 个月的校准数据集，它包含真正的后台业务数据； 还有一个收集了 2016 年 7 月到 2016 年 8 月这 2 个月的测试数据集，它包含真实数据和生成的流量数据，这些生成的数据覆盖了许多已知的攻击类型。</p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://nesg.ugr.es/nesg-ugr16/index.php">https://nesg.ugr.es/nesg-ugr16/index.php</a></p><h1 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h1><h2 id="CTU-13"><a href="#CTU-13" class="headerlink" title="CTU-13"></a>CTU-13</h2><p><strong>数据集简介</strong></p><p>CTU-13 是 2011 年在捷克理工大学（Czech Technical University in Prague）捕获的僵尸网络流量数据集。CTU-13 数据集包含 13 个不同场景下捕获到的数据，在每个场景中，我们都执行了一个特定的恶意软件，这个恶意软件使用了多种协议并执行了不同的操作，详细内容请查阅 <a href="https://mcfp.weebly.com/the-ctu-13-dataset-a-labeled-dataset-with-botnet-normal-and-background-traffic.html">THE CTU-13 DATASET. A LABELED DATASET WITH BOTNET, NORMAL AND BACKGROUND TRAFFIC.</a>。</p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://mcfp.weebly.com/the-ctu-13-dataset-a-labeled-dataset-with-botnet-normal-and-background-traffic.html">https://mcfp.weebly.com/the-ctu-13-dataset-a-labeled-dataset-with-botnet-normal-and-background-traffic.html</a></p><h1 id="WEB-攻击"><a href="#WEB-攻击" class="headerlink" title="WEB 攻击"></a>WEB 攻击</h1><h2 id="HTTP-CSIC-2010"><a href="#HTTP-CSIC-2010" class="headerlink" title="HTTP CSIC 2010"></a>HTTP CSIC 2010</h2><p><strong>数据集简介</strong></p><p>CSIC 2010 西班牙国家研究委员会信息安全研究所（Consejo Superior de Investigaciones Científicas）开发，包含 36000 个正常请求和 25000 多个异常请求，包括但不限于 SQL 注入、信息收集、敏感文件泄露 和 XSS 等 WEB 攻击。</p><p>下图给出了 CSIC 2010 数据集的文件内容，这是 2 个 SQL 注入的 HTTP 请求样本，CSIC 2010 的样本都是这样的 HTTP 请求，请求方法包括主要是 GET 和 POST，还有少量 PUT 请求。</p><p><img src="/2021/06/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E9%9B%86/image-20210605205632632.png" alt="image-20210605205632632" style="zoom:50%;"></p><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="https://www.tic.itefi.csic.es/dataset/">https://www.tic.itefi.csic.es/dataset/</a></p><h1 id="垃圾邮件-amp-垃圾短信"><a href="#垃圾邮件-amp-垃圾短信" class="headerlink" title="垃圾邮件&amp;垃圾短信"></a>垃圾邮件&amp;垃圾短信</h1><h2 id="UCI-Spambase"><a href="#UCI-Spambase" class="headerlink" title="UCI Spambase"></a>UCI Spambase</h2><p><strong>数据集简介</strong></p><p>加州大学尔湾分校（Irvine, CA: University of California）收集的垃圾邮件数据集，它有 4601 个样本。</p><p>下面是 UCI Spambase 的一个样本，它有 58 个字段，包括 57 个特征和 1 个标签，最后一列是标签，0 代表该样本不是垃圾邮件，1 代表该样本是垃圾邮件。特征的具体说明可以查阅 <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/spambase/spambase.names">spambase.names</a>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">64</span>,<span class="hljs-number">0</span>.<span class="hljs-number">64</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">32</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">64</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">32</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>.<span class="hljs-number">29</span>,<span class="hljs-number">1</span>.<span class="hljs-number">93</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">96</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">778</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>.<span class="hljs-number">756</span>,<span class="hljs-number">61</span>,<span class="hljs-number">278</span>,<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-05</p></blockquote><p><a href="https://archive.ics.uci.edu/ml/datasets/Spambase">https://archive.ics.uci.edu/ml/datasets/Spambase</a></p><h2 id="UCI-SMS-Spam"><a href="#UCI-SMS-Spam" class="headerlink" title="UCI SMS Spam"></a>UCI SMS Spam</h2><p><strong>数据集简介</strong></p><p>加州大学尔湾分校收集的垃圾短信数据集，它有 5574 个样本，每个样本由 2 部分组成，第 1 部分是标签，第 2 部分是短信内容。</p><p>下面是此数据集的 2 个样本示例，标签和短信内容由制表符 <code>\t</code> 分隔，spam 代表这是一条垃圾短信，ham 代表这一条不是垃圾短信。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ham</span>Ok lar... Joking wif u oni...<br><span class="hljs-attribute">spam</span>Free entry in <span class="hljs-number">2</span> a wkly comp to win FA Cup final tkts <span class="hljs-number">21</span>st May <span class="hljs-number">2005</span>. Text FA to <span class="hljs-number">87121</span> to receive entry question(std txt rate)T&amp;C&#x27;s apply <span class="hljs-number">08452810075</span>over<span class="hljs-number">18</span>&#x27;s<br></code></pre></td></tr></table></figure><p><strong>数据集获取</strong></p><blockquote><p> 本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection">https://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection</a></p><h1 id="钓鱼网站-amp-钓鱼邮件"><a href="#钓鱼网站-amp-钓鱼邮件" class="headerlink" title="钓鱼网站&amp;钓鱼邮件"></a>钓鱼网站&amp;钓鱼邮件</h1><h2 id="UCI-Website-Phishing-Data-Set"><a href="#UCI-Website-Phishing-Data-Set" class="headerlink" title="UCI Website Phishing Data Set"></a>UCI Website Phishing Data Set</h2><p><strong>数据集简介</strong></p><p>加州大学尔湾分校收集的钓鱼网站数据集，它有 1353 个样本。</p><p>下面是此数据集的 2 个样本示例，它有 10 个字段，其中包括 9 个特征和 1 个标签。最后一个字段代表标签，它有 3 个可取值 <code>&#123;1,0,-1&#125;</code>，1 代表合法，0 代表可疑，说明它可能是钓鱼网站，也可能不是钓鱼网站，-1 代表钓鱼网站。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">1,<span class="hljs-string">-1</span>,1,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,1,1,1,0,0<br><span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,0,1,1,1,1<br></code></pre></td></tr></table></figure><p>这 9 个特征分别是 <code>SFH, popUpWidnow, SSLfinal_State, Request_URL, URL_of_Anchor, web_traffic, URL_Length, age_of_domain 和 having_IP_Address</code> ，特征的具体含义和取值算法阅读文献 <em>Phishing Detection based Associative Classification Data Mining</em>，比如 SFH 是 Server Form Handler 的缩写<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="Abdelhamid, Neda, Aladdin Ayesh, and Fadi Thabtah. “Phishing detection based associative classification data mining.” Expert Systems with Applications 41.13 (2014): 5948-5959.">[7]</span></a></sup>，URL_Length 就是 URL 的长度，如果长度小于 54 则为 1，代表合法网站，长度在 <code>[54,74]</code> 之间代表可疑网站，长度大于 74 则代表是钓鱼网站，取值为 -1。</p><p><strong>数据集获取</strong></p><blockquote><p> 本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://archive.ics.uci.edu/ml/datasets/Website+Phishing">https://archive.ics.uci.edu/ml/datasets/Website+Phishing</a></p><h2 id="Phishing-Features-Dataset"><a href="#Phishing-Features-Dataset" class="headerlink" title="Phishing Features Dataset"></a>Phishing Features Dataset</h2><p><strong>数据集简介</strong></p><p>马来西亚砂拉越大学计算机科学与信息技术学院<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="Chiew, Kang Leng, et al. “A new hybrid ensemble feature selection framework for machine learning-based phishing detection system.” Information Sciences 484 (2019): 153-166.">[8]</span></a></sup>制作的一个数据集，数据集从 2015 年 1 月至 2017 年 5 月收集了钓鱼网页和合法网页， 5000 个钓鱼网页和 5000 个合法网页，从 PhishTank 和 OpenPhish 的 URL 中选择了 5000 个钓鱼网页，还有 5000 个来自 Alexa 和 Common Crawl 存档的合法网页的 URL。</p><p>下面是此数据集的样本示例，包括 49 个字段，其中 48 项是特征，最后 1 项是标签。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">72</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">21</span>,<span class="hljs-number">44</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">0000000000</span>,<span class="hljs-number">0</span>.<span class="hljs-number">2500000000</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">0000000000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>数据集获取</strong></p><blockquote><p> 本文最后访问数据集时间：2021-06-06</p></blockquote><p><a href="https://data.mendeley.com/datasets/h3cgnj8hft/1">https://data.mendeley.com/datasets/h3cgnj8hft/1</a></p><h1 id="DGA"><a href="#DGA" class="headerlink" title="DGA"></a>DGA</h1><h2 id="360-DGA"><a href="#360-DGA" class="headerlink" title="360 DGA"></a>360 DGA</h2><p><strong>数据集简介</strong></p><p>360 提供的 DGA 数据集，全是恶意样本。</p><p>下面是此数据集的样本示例，包括 4 个字段，分别是 <code>所属DGA家族,域名,有效的开始时间,有效的结束时间</code>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nymaim</span>uvegpylvsj.net<span class="hljs-number">2021</span>-<span class="hljs-number">06</span>-<span class="hljs-number">08</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-number">2021</span>-<span class="hljs-number">06</span>-<span class="hljs-number">08</span> <span class="hljs-number">23</span>:<span class="hljs-number">59</span>:<span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><p><strong>数据集获取</strong></p><blockquote><p>本文最后访问数据集时间：2021-06-08</p></blockquote><p><a href="http://data.netlab.360.com/dga/">http://data.netlab.360.com/dga/</a></p><h1 id="数据集仓库"><a href="#数据集仓库" class="headerlink" title="数据集仓库"></a>数据集仓库</h1><h2 id="加拿大安全研究所"><a href="#加拿大安全研究所" class="headerlink" title="加拿大安全研究所"></a>加拿大安全研究所</h2><p>需要填写一些个人信息，提交表单后才能获得数据集。</p><blockquote><p>本文最后访问页面时间：2021-06-05</p></blockquote><p><a href="https://www.unb.ca/cic/datasets/index.html">https://www.unb.ca/cic/datasets/index.html</a></p><h2 id="SecRepo"><a href="#SecRepo" class="headerlink" title="SecRepo"></a>SecRepo</h2><blockquote><p>本文最后访问页面时间：2021-06-05</p></blockquote><p><a href="http://www.secrepo.com/">http://www.secrepo.com/</a></p><h2 id="CAIDA-Data"><a href="#CAIDA-Data" class="headerlink" title="CAIDA Data"></a>CAIDA Data</h2><blockquote><p>本文最后访问页面时间：2021-06-06</p></blockquote><p><a href="https://www.caida.org/catalog/datasets/overview/">https://www.caida.org/catalog/datasets/overview/</a></p><h2 id="Security-amp-Privacy-Laboratory"><a href="#Security-amp-Privacy-Laboratory" class="headerlink" title="Security &amp; Privacy Laboratory"></a>Security &amp; Privacy Laboratory</h2><blockquote><p>本文最后访问页面时间：2021-06-06</p></blockquote><p><a href="https://secplab.ppgia.pucpr.br/?q=trabid">https://secplab.ppgia.pucpr.br/?q=trabid</a></p><h2 id="Jason-Trost-博客"><a href="#Jason-Trost-博客" class="headerlink" title="Jason Trost 博客"></a>Jason Trost 博客</h2><p>这是汇丰银行网络安全分析引擎主管的博客网站，分享了一些数据集的地址</p><blockquote><p>本文最后访问页面时间：2021-06-06</p></blockquote><p><a href="http://www.covert.io/data-links/">http://www.covert.io/data-links/</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://archive.ll.mit.edu/ideval/docs/attackDB.html">https://archive.ll.mit.edu/ideval/docs/attackDB.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Lippmann, Richard, et al. “The 1999 DARPA off-line intrusion detection evaluation.” Computer networks 34.4 (2000): 579-595.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>杨怡, 边媛, 张天桥. 基于机器学习的网络安全态势感知[J]. 计算机科学与应用, 2020, 10(12): 2431-2438.<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="http://kdd.ics.uci.edu/databases/kddcup99/task.html">http://kdd.ics.uci.edu/databases/kddcup99/task.html</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>翟明芳, 张兴明, 赵博. 基于深度学习的加密恶意流量检测研究[J]. 网络与信息安全学报, 2020, 6(03): 66-77.<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>Moustafa, Nour, and Jill Slay. “UNSW-NB15: a comprehensive data set for network intrusion detection systems (UNSW-NB15 network data set).” 2015 military communications and information systems conference (MilCIS). IEEE, 2015.<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>Abdelhamid, Neda, Aladdin Ayesh, and Fadi Thabtah. “Phishing detection based associative classification data mining.” <em>Expert Systems with Applications</em> 41.13 (2014): 5948-5959.<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>Chiew, Kang Leng, et al. “A new hybrid ensemble feature selection framework for machine learning-based phishing detection system.” <em>Information Sciences</em> 484 (2019): 153-166.<a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>数据集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
      <tag>数据集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 寻找两个正序数组的中位数</title>
    <link href="/2021/05/31/LeetCode/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2021/05/31/LeetCode/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p></blockquote><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0.00000</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = []<br>输出：<span class="hljs-number">2.00000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>最简单的做法就是，合并两个数组，然后进行排序，取出中位数即可。</p><p>需要注意的是奇数长度和偶数长度的数组，中位数的取法不同。</p><p><img src="/2021/05/31/LeetCode/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/04-01.svg" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>        nums = nums1 + nums2<br>        nums.sort()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>:<br>            mid = <span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> nums[mid]<br>        <span class="hljs-keyword">else</span>:<br>            mid_2 = <span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span><br>            mid_1 = mid_2 - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> (nums[mid_1] + nums[mid_2])/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="利用二分法"><a href="#利用二分法" class="headerlink" title="利用二分法"></a>利用二分法</h2><p>题目希望我们以 $O(log(M+N))$ 的时间复杂度解决此题，<code>log</code> 的时间复杂度，加上两个数组已经是正序的，这可以联想到二分法，因此考虑用二分法解决此题。</p><p>根据第一种解法，设合并后的数组长度为 <code>L</code>，奇数长度的数组中位数是第 <code>L//2 + 1</code> 个数字，偶数长度的数组中位数是第 <code>L//2</code> 和 <code>L//2 +1</code>，其实相当于寻找第 <code>k</code> 小的数字<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="LeetCode 官方题解：寻找两个有序数组的中位数">[1]</span></a></sup>，<code>k</code> 是 <code>L//2</code> 或 <code>L//2 + 1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>        m, n = <span class="hljs-built_in">len</span>(nums1), <span class="hljs-built_in">len</span>(nums2)<br>        k = (m+n) // <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (m+n)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, k)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> (findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, k-<span class="hljs-number">1</span>) + findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, k))/<span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKth</span>(<span class="hljs-params">nums1, start1, nums2, start2, k</span>):</span><br>    <span class="hljs-keyword">if</span> start1==<span class="hljs-built_in">len</span>(nums1):<br>        <span class="hljs-comment"># 排除了 nums1 的所有元素</span><br>        <span class="hljs-keyword">return</span> nums2[start2 + k - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">elif</span> start2==<span class="hljs-built_in">len</span>(nums2):<br>        <span class="hljs-comment"># 排除了nums2 的所有元素</span><br>        <span class="hljs-keyword">return</span> nums1[start1 + k - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">elif</span> k==<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[start1], nums2[start2])<br>    i = start1 + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(nums1), k//<span class="hljs-number">2</span>) - <span class="hljs-number">1</span><br>    j = start2 + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(nums2), k//<span class="hljs-number">2</span>) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> nums1[i] &lt; nums2[j]:<br>        k = k - (i - start1 + <span class="hljs-number">1</span>)<br>        start1 = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> findKth(nums1, start1, nums2, start2, k)<br>    <span class="hljs-keyword">else</span>:<br>        k = k - (j - start2 + <span class="hljs-number">1</span>)<br>        start2 = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> findKth(nums1, start1, nums2, start2, k)<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">LeetCode 官方题解：寻找两个有序数组的中位数</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数组</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p></blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;&quot;</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题可以用双指针来做，这里以查找字符串 <code>&quot;abcbb&quot;</code> 为例，查看一下大致的流程</p><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-01.svg" alt></p><blockquote><p>一开始，我们初始化最大长度、当前结果和当前长度、左右指针。当前结果用集合来存放，帮助我们快速判断是否存在重复字符</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-02.svg" alt></p><blockquote><p>首先，左右指针均指向第一个字符，当前结果为 <code>&quot;a&quot;</code>，其长度大于最大长度 0，更新最大长度为 1</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-03.svg" alt></p><blockquote><p>右指针往右搜索，此时指向字符 <code>&quot;b&quot;</code>，字符 <code>&quot;b&quot;</code> 不在当前结果中，故当前结果为 <code>&quot;ab&quot;</code>，更新最大长度为 2</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-04.svg" alt></p><blockquote><p>右指针继续搜索，<code>&quot;c&quot;</code> 同样没有重复，更新最大长度为 3</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-05.svg" alt></p><blockquote><p>右指针再往右时指向了字符 <code>&quot;b&quot;</code>，而 <code>&quot;b&quot;</code> 是一个重复字符，这时需要让左指针往右移动，直到当前子串中没有重复字符</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-06.svg" alt></p><blockquote><p>左指针指向下一个字符，此时子串为 <code>&quot;bcb&quot;</code>，仍有重复字符 <code>&quot;b&quot;</code>，左指针还需要继续往右移动</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-07.svg" alt></p><blockquote><p>此时子串为 <code>&quot;cb&quot;</code>，没有重复字符，但是长度为 2，不更新最大长度</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-08.svg" alt></p><blockquote><p>右指针往右，此时子串为 <code>&quot;cbb&quot;</code>，出现重复字符 <code>&quot;b&quot;</code>，右移左指针</p></blockquote><p><img src="/2021/05/31/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/03-09.svg" alt></p><blockquote><p>左指针不断右移，直到子串没有重复的字符，在我们的例子中，这时 <code>left=right=4</code>，子串为 <code>&quot;b&quot;</code>，不更新最大长度。</p><p>此时已经遍历完整个字符串，输出我们记录的最大长度即可。</p></blockquote><p>如果用文字表示上图的流程，大致为：</p><ul><li>初始化所需的变量；</li><li>遍历字符串 <code>s</code> 中的每个字符；<ul><li>如果 <code>left</code> 和 <code>right</code> 截取的子串没有重复的字符，更新当前的子串，如果当前子串长度大于最大长度，则更新最大长度；</li><li>如果 <code>right</code> 指向的字符出现了重复，则 <code>left</code> 往右增长，直到当前子串中没有重复的字符，更新当前子串，如果当前子串的长度大于最大长度，则更新最大长度。</li></ul></li><li>返回最大长度。</li></ul><p>根据上述流程，实现的 python 代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        max_len, cur_len = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        left = right = <span class="hljs-number">0</span><br>        lookup = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">while</span> s[right] <span class="hljs-keyword">in</span> lookup:<br>                lookup.remove(s[left])<br>                left += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            lookup.add(s[right])<br>            cur_len = <span class="hljs-built_in">len</span>(lookup)<br>            <span class="hljs-keyword">if</span> cur_len &gt; max_len:<br>                max_len = cur_len<br>        <span class="hljs-keyword">return</span> max_len<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 两数相加</title>
    <link href="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p></blockquote><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这里以 <code>22 + 79</code> 为例，我们看一下大致的流程</p><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-00.svg" alt></p><blockquote><p><code>22+79=101</code>，我们的链表逆序存储，返回的结果应为 <code>1 → 0 → 1</code></p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-01.svg" alt></p><blockquote><p>我们初始化一个链表，用来存放求和结果，这里设置了两个指针 <code>dummy</code> 和 <code>head</code>，其中 <code>head</code> 跟随着计算结果不断指向链表尾部，<code>dummy</code> 一直指向初始化链表的头部，最后返回 <code>dummy.next</code> 就可以得到所求的链表</p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-02.svg" alt></p><blockquote><p>首先是个位相加，得到结果 11，所以个位求和后，进位为1，本位也为 1，因此 <code>head</code> 的下一个结点存放本位的结果 1。</p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-03.svg" alt></p><blockquote><p>上一步个位求和结果有进位 1，因此这里要求和的是 <code>1+2+7=10</code>，即进位为1，本位为 0。 <code>head</code> 的下一个结点存放本位的结果 0</p></blockquote><p><img src="/2021/05/22/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/02-04.svg" alt></p><blockquote><p>上一步进行十位求和的结果中有一个进位 1，所以我们还需要继续计算下去，但是一开始求和的是两位数 22 和 79，存放这两个数值的链表取到百位的时候是 <code>None</code>，<code>None</code> 是没有属性 <code>val</code>，因此计算时要把 <code>val</code> 赋为 0。最后计算得到 <code>1</code>，本位为 1，进位为 0。</p><p><code>head</code> 的下一个结点存放本位的结果 1，这时候 <code>dummy</code> 指向的是初始化的头结点，返回 <code>dummy.next</code> 才是所求的链表</p></blockquote><p>图中的流程大致可以用文字描述为：</p><ul><li>初始化一个存放结果的链表 <code>head</code>，初始化进位 <code>c</code> 为0；</li><li>如果 <code>l1</code> 或 <code>l2</code> 非空或者 <code>c</code> 非 0<ul><li>进行求和；如果 <code>l1</code> 非空，则取出 <code>l1</code> 中存放的值 <code>v_1</code>，若 <code>l1</code> 为空则设 <code>v_1</code> 为 0，<code>l2</code> 同理；</li><li>求和，<code>sum = c + v_1 + v_2</code>，计算进位 <code>c = sum //10</code>，链表下一个结点存放的值为本位 <code>head.next = ListNode(sum % 10)</code>；</li><li><code>head</code> 移动后链表尾部，<code>l1</code> 移动到下一个结点，如果 <code>l1</code> 为空则继续为设空，<code>l2</code> 同理。</li></ul></li><li>流程结束，返回 <code>dummy.next</code> 得到结果。</li></ul><p>根据上述流程，实现的 python 代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br>        dummy = head = ListNode()<br>        c = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> c:<br>            v_1 = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            v_2 = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-built_in">sum</span> = c + v_1 + v_2<br>            c = <span class="hljs-built_in">sum</span> // <span class="hljs-number">10</span><br>            head.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-built_in">sum</span> % <span class="hljs-number">10</span>)<br>            head = head.<span class="hljs-built_in">next</span><br>            l1 = l1.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>            l2 = l2.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 两数之和</title>
    <link href="/2021/05/22/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/05/22/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a></p></blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 103</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>利用两个 <code>for</code> 循环，找到求和等于 <code>target</code> 的数字下标即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,n):<br>                <span class="hljs-keyword">if</span> nums[i]+nums[j]==target:<br>                    <span class="hljs-keyword">return</span> [i,j]<br></code></pre></td></tr></table></figure><h2 id="利用字典"><a href="#利用字典" class="headerlink" title="利用字典"></a>利用字典</h2><p>两个 <code>for</code> 循环的时间复杂度为 $O(N^2)$，如果我们用字典记录之前看过的数字和对应的索引，遍历其他数字时，先计算该数字和 <code>target</code> 的差值 <code>diff=target-num</code>，如果 <code>diff</code> 在字典中，我们就能直接返回结果，而字典的查找时间复杂度为 <code>O(1)</code>，整个算法的时间复杂度降到 $O(N)$。流程如下：</p><ul><li>初始化一个字典；</li><li>开始遍历 <code>nums</code> 中的数字 <code>num</code>，计算 <code>diff=target-num</code> ，如果 <code>diff</code> 在字典中，结束流程，返回数字下标；如果 <code>diff</code> 不在字典中，我们在字典中添加一个元素，键为 <code>num</code>，值为 <code>num</code> 的下标；</li><li>不断重复此过程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        lookup = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            diff = target - num<br>            <span class="hljs-keyword">if</span> diff <span class="hljs-keyword">in</span> lookup:<br>                <span class="hljs-keyword">return</span> [lookup[diff],i]<br>            <span class="hljs-keyword">else</span>:<br>                lookup[num] = i<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>算法简介</strong></p><p>二分查找是在<strong>有序数组</strong>中寻找某一元素的查找算法，它的主要思想就是将搜索空间缩小为原来的一半。尽管二分查找的思想非常简单，但是很多人也容易出错，主要问题出现在代码对边界值的处理、比较符号带不带等号这些细节上。</p><p><strong>算法流程</strong></p><ul><li>设数组 <code>arr = [0, 1, …, N]</code>，初始化左边界 <code>left=0</code>，右边界 <code>right=len(arr)-1</code>，<code>mid</code> 为左右指针的中点；</li><li>取出 <code>mid</code> 指向的元素，如果此元素为查找的元素，结束查找过程，并返回结果；</li><li>如果 <code>mid</code> 指向的元素大于查找目标，因为数组有序，因此接下来查找 <code>arr[left, mid-1]</code>；如果此元素小于查找目标，那么接下来查找 <code>arr[mid+1, right]</code>；</li><li>更新 <code>left</code>、<code>right</code> 和 <code>mid</code>，不断重复此过程，如果搜索空间为空，说明数组 <code>arr</code> 中不存在所要寻找的值。</li></ul><p><strong>复杂度分析</strong></p><ul><li>平均时间复杂度 $O(\log N)$</li><li>最坏时间复杂度 $O(\log N)$</li><li>空间复杂度<ul><li>迭代实现： $O(1)$</li><li>递归实现： $O(\log N)$</li></ul></li></ul><h1 id="基本的二分查找"><a href="#基本的二分查找" class="headerlink" title="基本的二分查找"></a>基本的二分查找</h1><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210428231629222.svg" alt></p><blockquote><p>一开始 7 小于 11，下一步需要缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215308600.svg" alt></p><blockquote><p>14 大于 11，在上一步的基础上，缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215338299.svg" alt></p><blockquote><p>找到 11 所在的索引，返回索引值 3</p></blockquote><p>如上图所示，给定数组 <code>arr=[2,4,7,11,14,27]</code> 和 <code>target=11</code> 的查找流程，可用文字描述为：</p><ul><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>进入二分查找的循环体中，结束循环的条件为 <code>left&lt;=right</code>；</p><ul><li>计算 mid，<code>mid=left+(right-left)//2</code>，可以看做向下取整，这里没使用 <code>(left+right)//2</code> ，因为 left 和 right 直接相加时可能会出现溢出的情况；</li><li>判断 <code>arr[mid]</code> 和目标值的大小关系，如果相等，则结束查找流程，返回 target 的索引，即 mid；</li><li>如果 <code>arr[mid]</code> 大于目标值，可以缩小搜索空间为 <code>[left, mid-1]</code> ，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 小于目标值，可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果满足循环的条件，则不断重复此过程。</li></ul></li><li>结束循环，如果没有找到目标值，返回 -1。</li></ul><blockquote><p>结束循环的条件是 <code>left&lt;=right</code>，即我们的搜索空间为 <code>[left, right]</code>，这是一个闭区间。当 <code>left=right</code> 时，搜索空间不为空，仍然需要继续搜索，比如数组 <code>arr=[66]</code> 和 <code>target=66</code>，此时有 <code>left=right=0</code>，搜索空间为闭区间 <code>[0, 0]</code> ，即搜索的数组下标只有 0；如果用了 <code>left&lt;right</code>，就成了半开半闭区间 <code>[0, 0)</code> ，此时是一个空集合，程序不能正确返回结果。</p></blockquote><p>根据上面的描述内容，采用迭代的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">arr, target</span>):</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = left + (right-left)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> arr[mid] == target:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">elif</span> arr[mid]&gt;target:<br>            right = mid-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left = mid+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>采用递归的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">arr, target, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>    left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> left<br>    right = <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> right<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">or</span> left&gt;right:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    mid = left + (right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> arr[mid]==target:<br>        <span class="hljs-keyword">return</span> mid<br>    <span class="hljs-keyword">elif</span> arr[mid]&gt;target:<br>        right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search(arr, target, left, right)<br>    <span class="hljs-keyword">else</span>:<br>        left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search(arr, target, left, right)<br></code></pre></td></tr></table></figure><h1 id="寻找最左边界"><a href="#寻找最左边界" class="headerlink" title="寻找最左边界"></a>寻找最左边界</h1><p><strong>我们先来看看所查找的元素在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215558742.svg" alt></p><blockquote><p>mid 指向的元素刚好是 target，我们要找最左边界，那么需要查看 mid 左边是否还有 4 这个元素，缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215608740.svg" alt></p><blockquote><p>mid 指向的元素2 小于 4，需要缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429215621806.svg" alt></p><blockquote><p> 此时 mid 指向的元素刚好为 4，这是跟第一步一样，左边可能还存在元素 4，我们缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429220621111.svg" alt></p><blockquote><p>此时 right &lt; left，跳出循环体，left 指向的即为所查找目标的最左边界</p></blockquote><p><strong>我们再看看查找的目标值不在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221502600.svg" alt></p><blockquote><p>左右两边，目标值均大于 4，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221537732.svg" alt></p><blockquote><p>左边 14 大于目标值 6，缩小搜索空间为左半部分；右边 14 小于目标值 30，继续缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221606076.svg" alt></p><blockquote><p>左右两边均小于目标值，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429221625527.svg" alt></p><blockquote><p>缩小搜索空间后，左右两边 right&lt;left ，结束循环。此时左边的 left 指向的元素不为 6，而右边的 left 超出数组边界</p></blockquote><p>二分查找的一个应用是寻找满足条件的最左边界，如果不存在则返回-1，上图的查找流程，可用文字描述为：</p><ul><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>进入二分查找的循环体中，结束循环的条件为 <code>left&lt;=right</code>；</p><ul><li>计算 mid，<code>mid=left+(right-left)//2</code>；</li><li>判断 <code>arr[mid]</code> 和目标值的大小关系，因为我们要找的是最左边界，如果相等，mid 的左边可能依然存在我们的目标值，我们可以缩小搜索空间为 <code>[left, mid-1]</code>，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 大于目标值，可以缩小搜索空间为 <code>[left, mid-1]</code> ，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 小于目标值，可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果满足循环的条件，则不断重复此过程。</li></ul></li><li>结束循环，如果没有找到目标值，返回 -1；</li><li>如果找到目标值，返回 left 即为最左边界。</li></ul><p>根据上面的描述内容，采用迭代的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_left</span>(<span class="hljs-params">arr, target</span>):</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = left + (right - left)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> arr[mid] &gt;= target:<br>            right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;<span class="hljs-built_in">len</span>(arr) <span class="hljs-keyword">or</span> arr[left]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure><p>采用递归的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_left</span>(<span class="hljs-params">arr, target, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>    left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> left<br>    right = <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> right<br>    mid = left + (right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">or</span> left&gt;<span class="hljs-built_in">len</span>(arr):<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[left]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[left]==target:<br>        <span class="hljs-keyword">return</span> left<br>    <span class="hljs-keyword">if</span> arr[mid] &gt;= target:<br>        right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_left(arr, target, left, right)<br>    <span class="hljs-keyword">else</span>:<br>        left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_left(arr, target, left, right)<br></code></pre></td></tr></table></figure><h1 id="寻找最右边界"><a href="#寻找最右边界" class="headerlink" title="寻找最右边界"></a>寻找最右边界</h1><p><strong>我们先来看看所查找的元素在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429223719914.svg" alt></p><blockquote><p>mid 指向的目标值刚好为 4，我们要找的是最右边界，因此需要寻找 mid 右边是否还有 4，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429223732516.svg" alt></p><blockquote><p>mid 指向的元素是 14，大于查找目标4，因此缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429223735600.svg" alt></p><blockquote><p>此时 mid 指向的元素刚好是 4，跟第一步一样，我们要查找 mid 右边是否还有元素 4，缩小搜索空间为右半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224032037.svg" alt></p><blockquote><p>此时 right&lt;left，循环结束，right 指向的是查找目标的最右边界</p></blockquote><p><strong>我们再看看查找目标不在数组中的情况</strong></p><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224231519.svg" alt></p><blockquote><p>左边目标值 6 大于 4，缩小搜索空间为右半部分；右边目标值 1 小于 4，缩小搜索空间为左半部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224623562.svg" alt></p><blockquote><p>左边目标值 6 小于 14，缩小搜索空间为左半部分；右边目标值 1 小于2，缩小搜索空间为左边部分</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224627809.svg" alt></p><blockquote><p>左边目标值 6 大于 14，搜小搜索空间为右半部分；右边 right &lt; 0 &lt; left，循环结束</p></blockquote><p><img src="/2021/04/30/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210429224840436.svg" alt></p><blockquote><p>左边 right&lt;left，循环结束，且 right 指向的元素不是目标值</p></blockquote><p>二分查找的另一个应用是寻找满足条件的最右边界，如果不存在则返回-1，上图的查找流程，可用文字描述为：</p><ul><li><p>首先对 left 和 right 进行初始化 ，其中 <code>left=0</code> ，<code>right=len(arr)-1</code>；</p></li><li><p>进入二分查找的循环体中，结束循环的条件为 <code>left&lt;=right</code>；</p><ul><li>计算 mid，<code>mid=left+(right-left)//2</code>；</li><li>判断 <code>arr[mid]</code> 和目标值的大小关系，因为我们要找的是最左边界，如果相等，mid 的右边可能依然存在我们的目标值，我们可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果 <code>arr[mid]</code> 大于目标值，可以缩小搜索空间为 <code>[left, mid-1]</code> ，即令 <code>right=mid-1</code>；</li><li>如果 <code>arr[mid]</code> 小于目标值，可以缩小搜索空间为 <code>[mid+1, right]</code>，即令 <code>left=mid+1</code>；</li><li>如果满足循环的条件，则不断重复此过程。</li></ul></li><li>结束循环，如果没有找到目标值，返回 -1；</li><li>如果找到目标值，返回 right 即为最右边界。</li></ul><p>根据上面的描述内容，采用迭代的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_right</span>(<span class="hljs-params">arr, target</span>):</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = left + (right-left)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> arr[mid]&lt;=target:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> right&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> arr[right]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> right<br></code></pre></td></tr></table></figure><p>采用递归的方式实现，python 代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search_right</span>(<span class="hljs-params">arr, target, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>    left = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> left<br>    right = <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> right<br>    mid = left + (right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">or</span> right&lt;<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[right]!=target:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> left&gt;right <span class="hljs-keyword">and</span> arr[right]==target:<br>        <span class="hljs-keyword">return</span> right<br>    <span class="hljs-keyword">if</span> arr[mid]&lt;=target:<br>        left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_right(arr, target, left, right)<br>    <span class="hljs-keyword">else</span>:<br>        right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> binary_search_right(arr, target, left, right)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>查找</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>welcome</title>
    <link href="/2021/03/27/welcome/"/>
    <url>/2021/03/27/welcome/</url>
    
    <content type="html"><![CDATA[<p>兴趣使然的博客</p><p><img src="/2021/03/27/welcome/1.jpg" alt></p><script type="math/tex; mode=display">1.01^365=37.7834</script>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
